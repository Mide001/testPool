{"version":3,"file":"static/js/2313.304aadb8.chunk.js","mappings":"y0CAAaA,EAAU,kB,iCCYjBC,EAAS,IAAIC,EAAAA,GAAOF,GAiBbG,EAAS,WAGlB,SAAAA,KAAAC,EAAAA,EAAAA,GAAA,KAAAD,GACIF,EAAOI,SAAS,gBAADF,EAAA,KAAAG,iBAAA,EAAaH,GAC5BI,KAAKC,QAAUD,KAAKE,mBACxB,CAqcC,OArcAC,EAAAA,EAAAA,GAAAP,EAAA,EAAAQ,IAAA,oBAAAC,MAED,WAAiB,IAAAC,EAAA,KACPL,EAA6B,CAAC,EAE9BM,EAAUP,KAAKO,QAAQC,KAAKR,MAC5BS,EAAYT,KAAKS,UAAUD,KAAKR,MAChCU,EAAWV,KAAKU,SAASF,KAAKR,MAC9BW,EAAOX,KAAKW,KAAKH,KAAKR,MACtBY,EAAOZ,KAAKY,KAAKJ,KAAKR,MACtBa,EAAMb,KAAKa,IAAIL,KAAKR,MACpBc,EAASd,KAAKc,OAAON,KAAKR,MAC1Be,EAAOf,KAAKe,KAAKP,KAAKR,MAmI5B,OA/HAC,EAAQe,YAAc,CAClBJ,KAAMA,EAENG,KAAMA,EACNE,WAAYrB,EAAUsB,UAAUlB,KAAKiB,WAAWT,KAAKR,MAAO,MAE5DmB,UAAWvB,EAAUsB,UAAUN,EAAM,MACrCQ,YAAaxB,EAAUsB,UAAUJ,EAAQ,MACzCO,iBAAkBzB,EAAUsB,UAAUJ,EAAQ,MAE9CQ,cAAe1B,EAAUsB,UAAUJ,EAAQ,MAE3CS,KAAMhB,EAINiB,SAAU5B,EAAUsB,UAAUT,GAC9BgB,qBAAsB7B,EAAUsB,UAAUT,GAC1CiB,aAAc9B,EAAUsB,UAAUT,GAElCkB,SAAUlB,EACVmB,GAAIhC,EAAUsB,UAAUX,EAAS,MACjCF,MAAOI,EACPoB,MAAOf,EACPH,KAAMA,EAENmB,EAAGlC,EAAUsB,UAAUlB,KAAK+B,SAC5BC,EAAGpC,EAAUsB,UAAUlB,KAAK+B,SAC5BE,EAAGrC,EAAUsB,UAAUJ,GAEvBoB,QAAStC,EAAUsB,UAAUX,EAAS,MAEtC4B,IAAKvC,EAAUsB,UAAUP,IAG7BV,EAAQmC,mBAAqB,CACzBb,KAAM3B,EAAUsB,UAAUX,GAC1BsB,MAAOjC,EAAUsB,UAAUJ,GAC3Ba,SAAU/B,EAAUsB,UAAUT,GAC9Be,SAAU5B,EAAUsB,UAAUT,GAC9BgB,qBAAsB7B,EAAUsB,UAAUT,GAC1CiB,aAAc9B,EAAUsB,UAAUT,GAClCmB,GAAIhC,EAAUsB,UAAUX,GACxBF,MAAOT,EAAUsB,UAAUT,GAC3BE,KAAMf,EAAUsB,WA9CD,SAACe,GAAa,OAAO3B,EAAKK,KAAKsB,GAAG,EAAO,IA+CxDlB,KAAMnB,EAAUsB,UAAUJ,GAC1BG,WAAYrB,EAAUsB,UAAUlB,KAAKiB,WAAWT,KAAKR,MAAO,OAGhEC,EAAQoC,WAAa,CACjBhB,iBAAkBP,EAClBM,YAAaN,EACbwB,gBAAiB1B,EACjBL,QAASA,EACTgC,OAAQ3C,EAAU4C,QAAQ5B,GAC1BD,KAAMA,EACN8B,SAAU3B,EACVK,UAAWP,GAGfX,EAAQyC,QAAU,CACdd,GAAIhC,EAAUsB,UAAUlB,KAAKO,QAAS,MACtCgB,KAAM3B,EAAUsB,UAAUlB,KAAKO,QAAS,MACxCoC,gBAAiB/C,EAAUsB,UAAUX,EAAS,MAC9Cc,iBAAkBP,EAElB8B,KAAMhD,EAAUsB,UAAUL,GAC1BgC,QAASpC,EACTqC,UAAWlD,EAAUsB,UAAUP,GAC/BQ,UAAWP,EACX0B,gBAAiB1B,EACjBmC,KAAMnD,EAAU4C,QAAQxC,KAAKqC,WAAW7B,KAAKR,OAC7CoB,YAAaN,EACbQ,cAAe1B,EAAUsB,UAAUJ,EAAQ,MAC3CkC,kBAAmBvC,EACnBwC,kBAAmBrD,EAAUsB,UAAUT,GACvCyC,OAAQtD,EAAUsB,UAAUJ,GAC5BC,KAAMA,GAGVd,EAAQkD,MAAQ,CACZvC,KAAMA,EACNwC,WAAYxC,EACZE,OAAQA,EAERuC,UAAWvC,EACXe,MAAOjC,EAAUsB,UAAUL,GAC3ByC,WAAYtD,KAAKsD,WAAW9C,KAAKR,MAEjC2B,SAAUlB,EACVoC,QAASpC,EAET8C,MAAOhD,EACPiD,UAAW7C,EAEX8C,aAAc7D,EAAUsB,UAAUtB,EAAU4C,QAAQ5B,IAEpD8C,cAAe9D,EAAUsB,UAAUT,IAGvCR,EAAQ0D,uBAAwBC,EAAAA,EAAAA,IAAY3D,EAAQkD,OACpDlD,EAAQ0D,sBAAsBF,aAAe7D,EAAUsB,UAAUtB,EAAU4C,QAAQxC,KAAK6D,oBAAoBrD,KAAKR,QAEjHC,EAAQ6D,OAAS,CACbC,UAAWnE,EAAUsB,UAAUR,OAAUsD,GACzCC,QAASrE,EAAUsB,UAAUR,OAAUsD,GACvC7C,UAAWvB,EAAUsB,UAAUN,OAAMoD,GACrCzD,QAASX,EAAUsB,UAAUX,OAASyD,GACtCzB,OAAQ3C,EAAUsB,UAAUlB,KAAKuC,OAAO/B,KAAKR,WAAOgE,IAGxD/D,EAAQiE,UAAY,CAChB9C,YAAaxB,EAAUsB,UAAUJ,GACjCK,UAAWvB,EAAUsB,UAAUN,GAC/BS,iBAAkBP,EAElBqD,QAASvE,EAAUsB,UAAUlB,KAAKoE,QAAQ5D,KAAKR,OAE/CO,QAASA,EACTI,KAAMf,EAAUyE,aAAa1D,EAAM,MAEnC4B,OAAQ3C,EAAU4C,QAAQ5B,GAE1B0B,gBAAiB1B,EACjB6B,SAAU3B,GAGPb,CACX,GAAC,CAAAG,IAAA,aAAAC,MAED,SAAWY,GACP,OAAOqD,EAAAA,EAAAA,IAAcrD,GAAc,GACvC,GAGA,CAAAb,IAAA,SAAAC,MACA,SAAOS,GACH,MAAe,OAAXA,EAA0B,EACvByD,EAAAA,GAAUhD,KAAKT,GAAQ0D,UAClC,GAAC,CAAApE,IAAA,OAAAC,MAED,SAAKS,GACD,MAAe,OAAXA,GAA6B,MAAVA,EAAyB,EACzCyD,EAAAA,GAAUhD,KAAKT,GAAQ0D,UAClC,GAEA,CAAApE,IAAA,YAAAC,MACA,SAAUA,GACN,OAAOkE,EAAAA,GAAUhD,KAAKlB,EAC1B,GAEA,CAAAD,IAAA,UAAAC,MACA,SAAQA,GACJ,GAAsB,mBAAXA,EAAwB,OAAOA,EAC1C,GAAsB,kBAAXA,EAAqB,CAE5B,GAAc,UADdA,EAAQA,EAAMoE,eACU,OAAO,EAC/B,GAAc,UAAVpE,EAAqB,OAAO,C,CAEpC,MAAM,IAAIqE,MAAM,qBAAuBrE,EAC3C,GAAC,CAAAD,IAAA,MAAAC,MAED,SAAIA,EAAYsE,GACZ,MAAsB,kBAAXtE,IACFsE,GAAoC,OAA1BtE,EAAMuE,UAAU,EAAG,KAAevE,EAAQ,KAAOA,IAC5DwE,EAAAA,EAAAA,IAAYxE,IACNA,EAAMoE,cAGb/E,EAAOoF,mBAAmB,eAAgB,QAASzE,EAC9D,GAAC,CAAAD,IAAA,OAAAC,MAED,SAAKA,EAAYsE,GACb,IAAMI,EAAS/E,KAAKa,IAAIR,EAAOsE,GAC/B,GAAKI,EAAOC,OAAS,IAAO,EACxB,MAAM,IAAIN,MAAM,8BAAgCrE,GAEpD,OAAO0E,CACX,GAGA,CAAA3E,IAAA,UAAAC,MACA,SAAQA,GACJ,OAAO4E,EAAAA,EAAAA,IAAW5E,EACtB,GAAC,CAAAD,IAAA,cAAAC,MAED,SAAYA,GACR,KAAKwE,EAAAA,EAAAA,IAAYxE,EAAO,IAAO,OAAO,KACtC,IAAME,GAAU0E,EAAAA,EAAAA,KAAWC,EAAAA,EAAAA,IAAa7E,EAAO,KAC/C,OAAQE,IAAY4E,EAAAA,EAAe,KAAM5E,CAC7C,GAAC,CAAAH,IAAA,kBAAAC,MAED,SAAgBA,GACZ,OAAO+E,EAAAA,EAAAA,IAAmB/E,EAC9B,GAEA,CAAAD,IAAA,WAAAC,MACA,SAASK,GACL,GAAgB,MAAZA,EAAoB,MAAO,SAE/B,GAAiB,aAAbA,EAA2B,MAAO,MAEtC,GAAiB,WAAbA,GAAsC,YAAbA,EACzB,OAAOA,EAGX,GAAyB,kBAAdA,IAA0BmE,EAAAA,EAAAA,IAAYnE,GAC7C,OAAO2E,EAAAA,EAAAA,IAA0B3E,GAGrC,MAAM,IAAIgE,MAAM,mBACpB,GAEA,CAAAtE,IAAA,OAAAC,MACA,SAAKA,EAAYsE,GACb,IAAMI,EAAS/E,KAAKa,IAAIR,EAAOsE,GAC/B,OAA8B,MAA1BW,EAAAA,EAAAA,IAAcP,GACPrF,EAAOoF,mBAAmB,eAAgB,QAASzE,GAEvD0E,CACX,GAEA,CAAA3E,IAAA,aAAAC,MACA,SAAWA,GACP,GAAa,MAATA,EAAiB,OAAO,KAE5B,IAAM4B,EAAIsC,EAAAA,GAAUhD,KAAKlB,GAEzB,IACI,OAAO4B,EAAEuC,U,CACX,MAAOe,GAAQ,CAElB,OAAO,IACV,GAAC,CAAAnF,IAAA,UAAAC,MAED,SAAQA,GACJ,KAAKwE,EAAAA,EAAAA,IAAYxE,GACb,MAAM,IAAIqE,MAAM,mBAEpB,OAAOc,EAAAA,EAAAA,IAAWnF,EAAO,GAC7B,GAAC,CAAAD,IAAA,SAAAC,MAED,SAAOA,EAAYoF,GACK,MAAhBpF,EAAMqF,QAAiC,MAAfrF,EAAMkD,QAC9BlD,EAAMkD,MAAQlD,EAAMqF,QAGxB,IAAMpC,EAAmC,MAArBjD,EAAMsF,YAAuBtF,EAAMsF,YAAatF,EAAMiD,WACpEyB,EAASnF,EAAUgG,MAAMH,EAAQpF,GAEvC,OADA0E,EAAOY,YAA8B,MAAdrC,EAAsB,KAAMiB,EAAAA,GAAUhD,KAAK+B,GAC3DyB,CACX,GAAC,CAAA3E,IAAA,QAAAC,MAED,SAAMA,GACF,OAAOL,KAAK6F,OAAOxF,EAAOL,KAAKC,QAAQkD,MAC3C,GAAC,CAAA/C,IAAA,wBAAAC,MAED,SAAsBA,GAClB,OAAOL,KAAK6F,OAAOxF,EAAOL,KAAKC,QAAQ0D,sBAC3C,GAEA,CAAAvD,IAAA,qBAAAC,MACA,SAAmBA,GACf,OAAOT,EAAUgG,MAAM5F,KAAKC,QAAQmC,mBAAoB/B,EAC5D,GAAC,CAAAD,IAAA,sBAAAC,MAED,SAAoBW,GAGO,MAAnBA,EAAY8E,KAAuC,MAAxB9E,EAAYW,WACvCX,EAAYW,SAAWX,EAAY8E,KAKnC9E,EAAYY,IAAM2C,EAAAA,GAAUhD,KAAKP,EAAYY,IAAImE,WACjD/E,EAAYY,GAAK,8CAII,MAArBZ,EAAYgF,OAAqC,MAApBhF,EAAYL,OACzCK,EAAYL,KAAOK,EAAYgF,OAIb,MAAlBhF,EAAYY,IAAqC,MAAvBZ,EAAYkB,UACtClB,EAAYkB,QAAUlC,KAAK2C,gBAAgB3B,IAGrB,IAArBA,EAAYD,MAAmC,IAArBC,EAAYD,MAAwC,MAA1BC,EAAYC,aACjED,EAAYC,WAAa,IAG7B,IAAM8D,EAA8BnF,EAAUgG,MAAM5F,KAAKC,QAAQe,YAAaA,GAE9E,GAA2B,MAAvBA,EAAYiF,QAAiB,CAC7B,IAAIA,EAAUjF,EAAYiF,SAEtBpB,EAAAA,EAAAA,IAAYoB,KACZA,EAAU1B,EAAAA,GAAUhD,KAAK0E,GAASzB,YAGtCO,EAAOkB,QAAUA,C,KAEd,CACH,IAAIA,EAAUjF,EAAYkF,UAGX,MAAXD,GAA+B,MAAZlB,EAAO9C,IAC1BgE,EAAUjF,EAAYiF,UAGtBpB,EAAAA,EAAAA,IAAYoB,KACZA,EAAU1B,EAAAA,GAAUhD,KAAK0E,GAASzB,YAGd,kBAAbyB,GAAqC,MAAZlB,EAAO9C,KACvCgE,GAAWlB,EAAO9C,EAAI,IAAM,GACd,IAAKgE,EAAU,GAC7BA,EAAUE,SAASF,IAGC,kBAAbA,IAAyBA,EAAU,GAE9ClB,EAAOkB,QAAUA,C,CAQrB,OAJIlB,EAAO5D,WAAoD,MAAvC4D,EAAO5D,UAAUiF,QAAQ,KAAM,MACnDrB,EAAO5D,UAAY,MAGhB4D,CACX,GAAC,CAAA3E,IAAA,cAAAC,MAED,SAAYA,GACR,OAAOgG,EAAAA,EAAAA,IAAiBhG,EAC5B,GAAC,CAAAD,IAAA,aAAAC,MAED,SAAWA,GACP,OAAOT,EAAUgG,MAAM5F,KAAKC,QAAQoC,WAAYhC,EACpD,GAAC,CAAAD,IAAA,UAAAC,MAED,SAAQA,GACJ,IAAM0E,EAA6BnF,EAAUgG,MAAM5F,KAAKC,QAAQyC,QAASrC,GAGzE,GAAmB,MAAf0E,EAAOnC,KACP,GAAImC,EAAOnC,KAAKoC,QAAU,EAAG,CAEzB,IAAM3E,EAAQkE,EAAAA,GAAUhD,KAAKwD,EAAOnC,MAAM4B,WAC5B,IAAVnE,GAAyB,IAAVA,GAEM,MAAjB0E,EAAO7B,QAAmB6B,EAAO7B,SAAW7C,GAC5CX,EAAOoF,mBAAmB,kCAAmC,QAAS,CAAElC,KAAMmC,EAAOnC,KAAMM,OAAQ6B,EAAO7B,SAE9G6B,EAAO7B,OAAS7C,SACT0E,EAAOnC,MAEdlD,EAAOoF,mBAAmB,0BAA2B,aAAcC,EAAOnC,K,MAEhD,KAAvBmC,EAAOnC,KAAKoC,QAEnBtF,EAAOoF,mBAAmB,oBAAqB,aAAcC,EAAOnC,MAQ5E,OAJqB,MAAjBmC,EAAO7B,SACP6B,EAAOuB,WAAY,GAGhBvB,CACX,GAAC,CAAA3E,IAAA,SAAAC,MAED,SAAOA,GAAU,IAAAkG,EAAA,KACb,OAAIC,MAAMC,QAAQpG,GACPA,EAAMqG,KAAI,SAACzE,GAAC,OAAKsE,EAAKhE,OAAON,EAAE,IAEtB,MAAT5B,EACAL,KAAKY,KAAKP,GAAO,GAGrB,IACX,GAAC,CAAAD,IAAA,SAAAC,MAED,SAAOA,GACH,OAAOT,EAAUgG,MAAM5F,KAAKC,QAAQ6D,OAAQzD,EAChD,GAAC,CAAAD,IAAA,YAAAC,MAED,SAAUA,GACN,OAAOT,EAAUgG,MAAM5F,KAAKC,QAAQiE,UAAW7D,EACnD,IAAC,EAAAD,IAAA,QAAAC,MAED,SAAaoF,EAA0CkB,GACnD,IAAM5B,EAAc,CAAC,EACrB,IAAK,IAAM3E,KAAOqF,EACd,IACI,IAAMpF,EAAQoF,EAAOrF,GAAKuG,EAAOvG,SACnB4D,IAAV3D,IAAuB0E,EAAO3E,GAAOC,E,CAC3C,MAAOkF,GAGL,MAFAA,EAAMqB,SAAWxG,EACjBmF,EAAMsB,WAAaF,EAAOvG,GACpBmF,C,CAGd,OAAOR,CACX,GAEA,CAAA3E,IAAA,YAAAC,MACA,SAAiBoF,EAAoBqB,GACjC,OAAQ,SAASzG,GACb,OAAa,MAATA,EAAwByG,EACrBrB,EAAOpF,EAClB,CACJ,GAEA,CAAAD,IAAA,eAAAC,MACA,SAAoBoF,EAAoBsB,GACpC,OAAQ,SAAS1G,GACb,OAAKA,EACEoF,EAAOpF,GADO0G,CAEzB,CACJ,GAEA,CAAA3G,IAAA,UAAAC,MACA,SAAeoF,GACX,OAAQ,SAASuB,GACb,IAAKR,MAAMC,QAAQO,GAAU,MAAM,IAAItC,MAAM,gBAE7C,IAAMK,EAAc,GAMpB,OAJAiC,EAAMC,SAAQ,SAAS5G,GACnB0E,EAAOmC,KAAKzB,EAAOpF,GACvB,IAEO0E,CACX,CACJ,KAACnF,CAAA,CA3ciB,GAkdhB,SAAUuH,EAAuB9G,GACnC,OAAQA,GAA+C,oBAA/BA,EAAM+G,mBAClC,CAEM,SAAUA,EAAoB/G,GAChC,OAAQ8G,EAAuB9G,IAAUA,EAAM+G,qBACnD,CAGA,IAAIC,GAAkB,EAChB,SAAUC,IACRD,IACJA,GAAkB,EAElBE,QAAQC,IAAI,8BACZD,QAAQC,IAAI,8DACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,6EACZD,QAAQC,IAAI,sEACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,2EACZD,QAAQC,IAAI,0EACZD,QAAQC,IAAI,iFACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,sDACZD,QAAQC,IAAI,8BAChB,C,0SCnfM9H,EAAS,IAAIC,EAAAA,GAAOF,GAO1B,SAASgI,EAAWC,GACf,OAAa,MAATA,EAAwB,QACC,MAAzBpC,EAAAA,EAAAA,IAAcoC,IACdhI,EAAOoF,mBAAmB,gBAAiB,QAAS4C,GAEjDA,EAAMjD,cAClB,CAEA,SAASkD,EAAgBpF,GAGrB,IADAA,EAASA,EAAOqF,QACTrF,EAAOyC,OAAS,GAAkC,MAA7BzC,EAAOA,EAAOyC,OAAS,IAAczC,EAAOsF,MAExE,OAAOtF,EAAOmE,KAAI,SAACgB,GACf,GAAIlB,MAAMC,QAAQiB,GAAQ,CAGtB,IAAMI,EAAyC,CAAC,EAChDJ,EAAMT,SAAQ,SAACS,GACXI,EAAOL,EAAWC,KAAU,CAChC,IAGA,IAAMK,EAASC,OAAOC,KAAKH,GAG3B,OAFAC,EAAOG,OAEAH,EAAOI,KAAK,I,CAGnB,OAAOV,EAAWC,EAE1B,IAAGS,KAAK,IACZ,CAgBA,SAASC,EAAYC,GACjB,GAA0B,kBAAfA,EAAyB,CAGhC,GAFAA,EAAYA,EAAU5D,cAEW,MAA7Ba,EAAAA,EAAAA,IAAc+C,GACd,MAAO,MAAQA,EAGnB,IAAgC,IAA5BA,EAAUC,QAAQ,KAClB,OAAOD,C,KAGR,IAAI7B,MAAMC,QAAQ4B,GACrB,MAAO,YAAcV,EAAgBU,GAElC,GAAIE,EAAAA,GAAUC,YAAYH,GAE7B,MADA3I,EAAO+I,KAAK,mBACN,IAAI/D,MAAM,mBAEb,GAAI2D,GAAmC,kBAAfA,EAC3B,MAAO,WAAaA,EAAU9H,SAAW,KAAO,IAAMoH,EAAgBU,EAAU9F,QAAU,G,CAG9F,MAAM,IAAImC,MAAM,mBAAqB2D,EACzC,CAKA,SAASK,IACL,OAAQ,IAAIC,MAAQD,SACxB,CAEA,SAASE,EAAMC,GACX,OAAO,IAAIC,SAAQ,SAACC,GAChBC,WAAWD,EAASF,EACxB,GACJ,CAmBA,IAAMI,EAAiB,CAAE,QAAS,UAAW,UAAW,QAE3CC,EAAK,WAKd,SAAAA,EAAYC,EAAaC,EAAoBC,IAAaxJ,EAAAA,EAAAA,GAAA,KAAAqJ,IACtDI,EAAAA,EAAAA,IAAetJ,KAAM,MAAOmJ,IAC5BG,EAAAA,EAAAA,IAAetJ,KAAM,WAAYoJ,IACjCE,EAAAA,EAAAA,IAAetJ,KAAM,OAAQqJ,EACjC,CAsCC,OAtCAlJ,EAAAA,EAAAA,GAAA+I,EAAA,EAAA9I,IAAA,QAAAmJ,IAED,WACI,OAAQvJ,KAAKe,MACT,IAAK,KACF,OAAOf,KAAKY,KACf,IAAK,SACF,OAAOZ,KAAK8D,OAEnB,OAAO9D,KAAKmJ,GAChB,GAAC,CAAA/I,IAAA,OAAAmJ,IAED,WACI,OAAOvJ,KAAKmJ,IAAIK,MAAM,KAAK,EAC/B,GAAC,CAAApJ,IAAA,OAAAmJ,IAED,WACI,IAAME,EAAQzJ,KAAKmJ,IAAIK,MAAM,KAC7B,MAAiB,OAAbC,EAAM,GAAsB,KACzBA,EAAM,EACjB,GAAC,CAAArJ,IAAA,SAAAmJ,IAED,WACI,IAAME,EAAQzJ,KAAKmJ,IAAIK,MAAM,KAC7B,GAAiB,WAAbC,EAAM,GAAmB,OAAO,KACpC,IA1GmB9I,EA0GbJ,EAAUkJ,EAAM,GAEhBlH,EA3GG,MADU5B,EA4Gc8I,EAAM,IA3GjB,GAEnB9I,EAAK6I,MAAM,MAAM9C,KAAI,SAACgB,GACzB,GAAc,KAAVA,EAAgB,MAAO,GAE3B,IAAM+B,EAAQ/B,EAAM8B,MAAM,KAAK9C,KAAI,SAACgB,GAChC,MAAmB,SAAVA,EAAoB,KAAMA,CACvC,IAEA,OAA0B,IAAjB+B,EAAMzE,OAAgByE,EAAM,GAAIA,CAC7C,IAkGU3F,EAAiB,CAAC,EAKxB,OAHIvB,EAAOyC,OAAS,IAAKlB,EAAOvB,OAASA,GACrChC,GAAuB,MAAZA,IAAmBuD,EAAOvD,QAAUA,GAE5CuD,CACX,GAAC,CAAA1D,IAAA,WAAAC,MAED,WACI,OAAQL,KAAKmJ,IAAIb,QAAQ,MAAQ,GAAKW,EAAeX,QAAQtI,KAAKmJ,MAAQ,CAC9E,KAACD,CAAA,CA/Ca,GAsFZQ,EAAgD,CAClD,EAAO,CAAEC,OAAQ,MAAQC,MAAO,EAAMC,KAAM,EAAMC,OAAQ,MAC1D,EAAO,CAAEH,OAAQ,MAAQC,MAAO,GAAMC,KAAM,GAAMC,OAAQ,OAC1D,EAAO,CAAEH,OAAQ,OAAQC,MAAO,GAAMC,KAAM,IAC5C,GAAO,CAAEF,OAAQ,MAAQI,IAAK,OAC9B,GAAO,CAAEJ,OAAQ,MAAQI,IAAK,OAC9B,IAAO,CAAEJ,OAAQ,OAAQI,IAAK,QAGlC,SAASC,EAAW3J,GAChB,OAAOmF,EAAAA,EAAAA,IAAWjB,EAAAA,GAAUhD,KAAKlB,GAAO4J,cAAe,GAC3D,CAGA,SAASC,EAAavJ,GAClB,OAAOwJ,EAAAA,GAAOC,QAAOC,EAAAA,EAAAA,IAAO,CAAE1J,GAAMuE,EAAAA,EAAAA,KAAaoF,EAAAA,EAAAA,KAAOA,EAAAA,EAAAA,IAAO3J,IAAQ,EAAG,KAC9E,CAOA,IAAM4J,EAAW,CACb,IAAIC,OAAO,mBAAqB,KAChC,IAAIA,OAAO,gBAAiB,KAC5B,IAAIA,OAAO,kBAAoB,KAC/B,IAAIA,OAAO,mCAAoC,MAGnD,SAASC,EAAa1F,GAClB,IACI,OAAO2F,EAAAA,EAAAA,IAAaC,EAAY5F,G,CAClC,MAAMQ,GAAQ,CAChB,OAAO,IACX,CAEA,SAASoF,EAAY5F,GACjB,GAAe,OAAXA,EAAmB,OAAO,KAE9B,IAAM6F,EAASrG,EAAAA,GAAUhD,MAAK2D,EAAAA,EAAAA,IAAaH,EAAQ,EAAG,KAAKP,WACrDQ,EAAST,EAAAA,GAAUhD,MAAK2D,EAAAA,EAAAA,IAAaH,EAAQ6F,EAAQA,EAAS,KAAKpG,WACzE,OAAOU,EAAAA,EAAAA,IAAaH,EAAQ6F,EAAS,GAAIA,EAAS,GAAK5F,EAC3D,CAGO,IAAM6F,EAAQ,WASjB,SAAAA,EAAYC,EAAwBvK,EAAiBwK,EAAcC,IAAwBnL,EAAAA,EAAAA,GAAA,KAAAgL,IACvFvB,EAAAA,EAAAA,IAAetJ,KAAM,WAAY8K,IACjCxB,EAAAA,EAAAA,IAAetJ,KAAM,OAAQ+K,IAC7BzB,EAAAA,EAAAA,IAAetJ,KAAM,UAAW8K,EAASG,UAAU1K,QAAQA,KAC3D+I,EAAAA,EAAAA,IAAetJ,KAAM,mBAAoBgL,EAC7C,CAoQC,OApQA7K,EAAAA,EAAAA,GAAA0K,EAAA,EAAAzK,IAAA,cAAAC,MAEK,SAAY6K,EAAkBC,G,qIAQT,OANjBC,EAAK,CACPxJ,GAAI5B,KAAKO,QACTI,MAAM0K,EAAAA,EAAAA,IAAU,CAAEH,GAAUI,EAAAA,EAAAA,IAAStL,KAAK+K,MAAQI,GAAc,QACnEI,EAAAC,KAAA,EAAAD,EAAAE,GAGUd,EAAWY,EAAAG,KAAA,EAAO1L,KAAK8K,SAASa,KAAKP,GAAG,cAAAG,EAAAK,GAAAL,EAAAM,KAAAN,EAAAO,OAAA,YAAAP,EAAAE,IAAAF,EAAAK,KAAA,UAAAL,EAAAC,KAAA,EAAAD,EAAAQ,GAAAR,EAAA,SAE3CA,EAAAQ,GAAMC,OAASrM,EAAAA,GAAOsM,OAAOC,eAAc,CAAAX,EAAAG,KAAA,gBAAAH,EAAAO,OAAA,SAAW,MAAI,eAAAP,EAAAO,OAAA,SACvD,MAAI,yBAAAP,EAAAY,OAAA,GAAAC,EAAA,iB,GAElB,CAAAhM,IAAA,cAAAC,MAED,SAAYgM,EAAkBC,GAC1B,IAAMC,EAAW7C,EAAU8C,OAAOH,IAQlC,GANgB,MAAZE,GACA7M,EAAO+M,WAAW,0BAADpC,OAA4BgC,GAAa1M,EAAAA,GAAOsM,OAAOS,sBAAuB,CAC3FC,UAAW,cAAFtC,OAAiBgC,EAAS,OAItB,QAAjBE,EAASxC,IACT,OAAO/J,KAAK8K,SAASG,UAAU1K,QAAQ+L,GAG3C,IAAMM,GAAQC,EAAAA,EAAAA,IAASP,GAGvB,GAAsB,MAAlBC,EAAS3C,MAAe,CACxB,IAAMA,EAAQ0C,EAASQ,MAAM,6CAC7B,GAAIlD,EAAO,CACP,IAAM5E,EAASmB,SAASyD,EAAM,GAAI,IAClC,GAAIA,EAAM,GAAG5E,SAAoB,EAATA,GAAcA,GAAU,GAAKA,GAAU,GAC3D,OAAOkF,GAAaG,EAAAA,EAAAA,IAAO,CAAE,CAAEkC,EAAS3C,OAAU,KAAOA,EAAM,K,EAM3E,GAAqB,MAAjB2C,EAAS1C,KAAc,CACvB,IAAMA,EAAOyC,EAASQ,MAAM,yCAC5B,GAAIjD,EAAM,CACN,IAAM7E,EAASmB,SAAS0D,EAAK,GAAI,IACjC,GAAIA,EAAK,GAAG7E,SAAoB,EAATA,GAAcA,GAAU,GAAKA,GAAU,GAC1D,OAAOkF,GAAaG,EAAAA,EAAAA,IAAO,CAAE,CAAEkC,EAAS1C,MAAS,KAAOA,EAAK,K,EAMzE,GAAuB,MAAnB0C,EAASzC,OAAgB,CACzB,IAAM9E,EAAS4H,EAAM,GAGjBnN,EAAUmN,EAAM,GASpB,GARgB,IAAZnN,EACe,KAAXuF,GAA4B,KAAXA,IACjBvF,GAAW,GAGfA,GAAW,EAGXA,GAAW,GAAKmN,EAAM5H,SAAW,EAAIA,GAAUA,GAAU,GAAKA,GAAU,GAAI,CAC5E,IAAM+H,EAAQC,IAAAA,QAAeJ,EAAMhF,MAAM,IAEzC,OADAmF,EAAME,QAAQxN,GACPuN,IAAAA,OAAcT,EAASzC,OAAQiD,E,EAI9C,OAAO,IACX,GAAC,CAAA3M,IAAA,aAAAC,MAGK,SAAWgM,G,2IAGb,GAFgB,MAAZA,IAAoBA,EAAW,IAGlB,KAAbA,EAAe,CAAAa,EAAAxB,KAAA,SAOM,OAPNwB,EAAA1B,KAAA,EAGLxK,EAAc,CAChBY,GAAI5B,KAAKO,QACTI,KAAO,cAAe2K,EAAAA,EAAAA,IAAStL,KAAK+K,MAAMnG,UAAU,IACvDsI,EAAAxB,KAAA,EACsB1L,KAAK8K,SAASa,KAAK3K,GAAY,OAAxC,GAGG,QAHXsL,EAAQY,EAAArB,OAGWS,IAAaa,EAAAA,EAAQ,CAAAD,EAAAxB,KAAA,eAAAwB,EAAApB,OAAA,SAAW,MAAI,cAAAoB,EAAApB,OAAA,SAEtD9L,KAAK8K,SAASG,UAAUmC,YAAYd,IAAS,WAAAY,EAAA1B,KAAA,GAAA0B,EAAAzB,GAAAyB,EAAA,SAEhDA,EAAAzB,GAAMO,OAASrM,EAAAA,GAAOsM,OAAOC,eAAc,CAAAgB,EAAAxB,KAAA,gBAAAwB,EAAApB,OAAA,SAAW,MAAI,cAAAoB,EAAAzB,GAAA,QAMrD,OANqDyB,EAAAxB,KAAA,GAM/C1L,KAAKqN,YAAY,aAAcrD,EAAWqC,IAAU,QAA7D,GAGE,OAHVC,EAAQY,EAAArB,OAGuB,OAAbS,EAAiB,CAAAY,EAAAxB,KAAA,gBAAAwB,EAAApB,OAAA,SAAW,MAAI,QAWvD,OANc,OAFTvL,EAAUP,KAAKsN,YAAYjB,EAAUC,KAGvC5M,EAAO+M,WAAW,mCAAoC9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACvFC,UAAW,cAAFtC,OAAiBgC,EAAS,KACnCA,SAAUA,EACV1L,KAAM2L,IAEbY,EAAApB,OAAA,SAEMvL,GAAO,yBAAA2M,EAAAf,OAAA,GAAAoB,EAAA,kB,GACjB,CAAAnN,IAAA,YAAAC,MAEK,W,+JAGiB,OAFbmN,EAAoD,GAAGC,EAAAjC,KAAA,EAAAiC,EAAA/B,KAAA,EAEpC1L,KAAK0N,QAAQ,UAAS,OAA/B,GACE,OADRC,EAAMF,EAAA5B,MACM,CAAA4B,EAAA/B,KAAA,eAAA+B,EAAA3B,OAAA,SAAW,MAAI,OAExB8B,EAAI,EAAC,YAAEA,EAAIrD,EAASvF,QAAM,CAAAyI,EAAA/B,KAAA,SACQ,GAE1B,OAFPoB,EAAQa,EAAOb,MAAMvC,EAASqD,KAEnB,CAAAH,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,uBAAA2B,EAAAhC,GACTqB,EAAM,GAAEW,EAAA/B,KACP,UADO+B,EAAAhC,GACA,GAIP,SAJOgC,EAAAhC,GAID,GAIN,SAJMgC,EAAAhC,GAIA,GAIN,WAJMgC,EAAAhC,IAKN,YADQgC,EAAAhC,GAAA,GACC,iBAZqC,OAA/C+B,EAAQtG,KAAK,CAAEnG,KAAM,MAAO8M,QAASF,IAAUF,EAAA3B,OAAA,SACxC,CAAE0B,QAAAA,EAASM,IAAKH,IAAQ,QAGiB,OAAhDH,EAAQtG,KAAK,CAAEnG,KAAM,OAAQ8M,QAASF,IAAUF,EAAA3B,OAAA,SACzC,CAAE0B,QAAAA,EAASM,IAAKH,IAAQ,QAGiB,OAAhDH,EAAQtG,KAAK,CAAEnG,KAAM,OAAQ8M,QAASF,IAAUF,EAAA3B,OAAA,SACzC,CAAE0B,QAAAA,EAASM,IAAK,gCAAFzD,OAAoCsD,EAAO/I,UAAU,MAAO,QAS7C,GAJ9BsG,EAAyB,WAAb4B,EAAM,GAAmB,aAAc,aACzDU,EAAQtG,KAAK,CAAEnG,KAAM+L,EAAM,GAAIe,QAASF,IAExCF,EAAA7B,GACe5L,KAAK+N,iBAAgBN,EAAA7B,GAAA,CAAA6B,EAAA/B,KAAA,SAAI,OAAJ+B,EAAA/B,KAAA,GAAU1L,KAAKiF,aAAY,QAAAwI,EAAA7B,GAAA6B,EAAA5B,KAAA,QAEtB,GAFnCmC,EAAKP,EAAA7B,GAGU,KADfnC,GAASqD,EAAM,IAAM,IAAItD,MAAM,MAC3BxE,OAAY,CAAAyI,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SAAW,MAAI,QAExB,OAFwB2B,EAAA/B,KAAA,GAElB1L,KAAK8K,SAASG,UAAU1K,QAAQkJ,EAAM,IAAG,QAG5D,GAHMwE,EAAIR,EAAA5B,KACJqC,GAAU1I,EAAAA,EAAAA,IAAWjB,EAAAA,GAAUhD,KAAKkI,EAAM,IAAIQ,cAAe,IAGlD,WAAb6C,EAAM,GAAe,CAAAW,EAAA/B,KAAA,SAEkC,OAFlC+B,EAAA1B,GAEF/L,KAAK8K,SAASG,UAASwC,EAAA/B,KAAA,GAAmB1L,KAAK8K,SAASa,KAAK,CAC5E/J,GAAIqM,EAAMtN,MAAM0K,EAAAA,EAAAA,IAAU,CAAE,aAAc6C,MAC5C,QAFoD,GAEpDT,EAAAU,GAAAV,EAAA5B,KAFIuC,EAAUX,EAAA1B,GAA2BqB,YAAWzB,KAAA8B,EAAA1B,GAAA0B,EAAAU,IAGlDH,IAAUI,EAAU,CAAAX,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SAAW,MAAI,QACvC0B,EAAQtG,KAAK,CAAEnG,KAAM,QAAS8M,QAASO,IAAcX,EAAA/B,KAAA,oBAEjC,YAAboB,EAAM,GAAgB,CAAAW,EAAA/B,KAAA,SAEE,OAFF+B,EAAAY,GAEb9J,EAAAA,GAASkJ,EAAA/B,KAAA,GAAY1L,KAAK8K,SAASa,KAAK,CACpD/J,GAAIqM,EAAMtN,MAAM0K,EAAAA,EAAAA,IAAU,CAAE,cAAc7F,EAAAA,EAAAA,IAAWwI,EAAO,IAAKE,MACnE,QAF4B,GAE5BT,EAAAa,GAAAb,EAAA5B,OAFI0C,EAAOd,EAAAY,GAAa9M,KAAIoK,KAAA8B,EAAAY,GAAAZ,EAAAa,KAGlBvI,SAAU,CAAF0H,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SAAW,MAAI,QACnC0B,EAAQtG,KAAK,CAAEnG,KAAM,UAAW8M,QAASU,EAAQC,aAAc,QAQpC,OAJzBpD,EAAK,CACPxJ,GAAI5B,KAAK8K,SAASG,UAAU1K,QAAQkJ,EAAM,IAC1C9I,MAAM0K,EAAAA,EAAAA,IAAU,CAAEH,EAAUgD,KAC/BT,EAAAgB,GACiBhE,EAAYgD,EAAA/B,KAAA,GAAO1L,KAAK8K,SAASa,KAAKP,GAAG,QAA5C,GAA4CqC,EAAAiB,GAAAjB,EAAA5B,KACxC,OADf8C,GAAc,EAAHlB,EAAAgB,IAAAhB,EAAAiB,KACQ,CAAAjB,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SAAW,MAAI,QASrB,OARjB0B,EAAQtG,KAAK,CAAEnG,KAAM,eAAgB8M,QAASc,IAG7B,YAAb7B,EAAM,KACN6B,EAAcA,EAAYvI,QAAQ,OAAQ8H,EAAQtJ,UAAU,KAGhE6I,EAAA/B,KAAA,IACuBkD,EAAAA,EAAAA,IAAUD,GAAY,QAA/B,IAARE,EAAQpB,EAAA5B,OAG8B,kBAApBgD,EAASC,OAAwBD,EAASC,MAAMhC,MAAM,gBAAe,CAAAW,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SAClF,MAAI,QAGwC,OADvD0B,EAAQtG,KAAK,CAAEnG,KAAM,WAAY8M,QAASkB,KAAKC,UAAUH,KACzDrB,EAAQtG,KAAK,CAAEnG,KAAM,MAAO8M,QAASgB,EAASC,QAASrB,EAAA3B,OAAA,SAEhD,CAAE0B,QAAAA,EAASM,IAAKe,EAASC,QAAO,QA1EdlB,IAAGH,EAAA/B,KAAA,gBAAA+B,EAAA/B,KAAA,iBAAA+B,EAAAjC,KAAA,GAAAiC,EAAAwB,GAAAxB,EAAA,wBAAAA,EAAA3B,OAAA,SAgFrC,MAAI,yBAAA2B,EAAAtB,OAAA,GAAA+C,EAAA,kB,GACd,CAAA9O,IAAA,iBAAAC,MAEK,W,2IAGe,O,SAAML,KAAKqN,YAAY,cAAa,OAAvC,GAGE,OAHVf,EAAQ6C,EAAAtD,OAGuB,OAAbS,EAAiB,CAAA6C,EAAAzD,KAAA,eAAAyD,EAAArD,OAAA,SAAW,MAAI,OAGoC,KAAtFsD,EAAO9C,EAASQ,MAAM,kEAClB,CAAFqC,EAAAzD,KAAA,SACgC,GAA9B1G,EAASmB,SAASiJ,EAAK,GAAI,IAC7BA,EAAK,GAAGpK,SAAoB,EAATA,EAAU,CAAAmK,EAAAzD,KAAA,gBAAAyD,EAAArD,OAAA,SACtB,UAAa3B,EAAAA,GAAOC,OAAO,KAAOgF,EAAK,KAAG,QAKI,KAAvDC,EAAQ/C,EAASQ,MAAM,kCAClB,CAAFqC,EAAAzD,KAAA,YACoB,KAArB2D,EAAM,GAAGrK,OAAmB,CAAAmK,EAAAzD,KAAA,gBAAAyD,EAAArD,OAAA,SACrB,SAAYuD,EAAM,IAAE,eAAAF,EAAArD,OAAA,SAI5BpM,EAAO+M,WAAW,2CAA4C9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACtGC,UAAW,mBACXhM,KAAM2L,KACR,yBAAA6C,EAAAhD,OAAA,GAAAmD,EAAA,S,GACL,CAAAlP,IAAA,UAAAC,MAEK,SAAQD,G,uIAcO,OAXbmP,GAAWC,EAAAA,EAAAA,IAAYpP,IAI3BmP,GAAWlF,EAAAA,EAAAA,IAAO,CAAEL,EAAW,IAAKA,EAAWuF,EAASvK,QAASuK,KAGnDvK,OAAS,KAAQ,IAC3BuK,GAAWlF,EAAAA,EAAAA,IAAO,CAAEkF,GAAU/J,EAAAA,EAAAA,IAAW,KAAM,GAAMpF,EAAI4E,OAAS,OACrEyK,EAAA/D,KAAA,EAEsB1L,KAAKqN,YAAY,cAAcqC,EAAAA,EAAAA,IAAQH,IAAU,OAA1D,GACE,OADVjD,EAAQmD,EAAA5D,OACuB,OAAbS,EAAiB,CAAAmD,EAAA/D,KAAA,eAAA+D,EAAA3D,OAAA,SAAW,MAAI,cAAA2D,EAAA3D,OAAA,UAEjDpB,EAAAA,EAAAA,IAAa4B,IAAS,wBAAAmD,EAAAtD,OAAA,GAAAwD,EAAA,S,KAChC9E,CAAA,CAlRgB,GAqRjB+E,EAA8B,KAE9BC,EAAa,EAEJC,EAAa,SAAAC,IAAAC,EAAAA,EAAAA,GAAAF,EAAAC,GAAA,IAAAE,GAAAC,EAAAA,EAAAA,GAAAJ,GA8CtB,SAAAA,EAAYK,GAAsC,IAAA7P,EAkB9C,IAlB8CT,EAAAA,EAAAA,GAAA,KAAAiQ,GAC9CpQ,EAAOI,SAAS,gBAADgQ,EAAA,KAAA/P,iBAAA,EAAaqQ,EAAAA,KAE5B9P,EAAA2P,EAAAtE,KAAA,OAGK0E,QAAU,GAEf/P,EAAKgQ,SAAW,CAAEnN,OAAQ,GAE1B7C,EAAK2K,WAAY,gBAAA6E,EAAA,KAAA/P,iBAAA,GAAWwQ,gBAK5BjH,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,aAA2B,QAAZ6P,GAChC7P,EAAKmQ,aAAcN,EAAU7P,EAAKoQ,iBAElCP,aAAmBrH,QACnBxI,EAAKqQ,gBAAkBR,EAGvBA,EAAQS,OAAM,SAACrL,GAAY,IAG3BjF,EAAKuQ,SAASD,OAAM,SAACrL,GAAY,QAE9B,CACH,IAAMuL,GAAeC,EAAAA,EAAAA,IAAS,gBAAAjB,EAAA,KAAA/P,iBAAA,EAA+C,aAAxDgR,CAAsEZ,GACvFW,IACAxH,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,WAAYwQ,GACjCxQ,EAAK0Q,KAAK,UAAWF,EAAc,OAGnCpR,EAAOoF,mBAAmB,kBAAmB,UAAWqL,E,CAUxC,OANxB7P,EAAK2Q,yBAA2B,KAEhC3Q,EAAK4Q,kBAAoB,EAEzB5Q,EAAK6Q,iBAAmB,IAExB7Q,EAAK8Q,eAAiB,EAAE9Q,CAC5B,CAgEC,OAhEAH,EAAAA,EAAAA,GAAA2P,EAAA,EAAA1P,IAAA,SAAAC,MAEK,W,wIACmB,MAAjBL,KAAKqR,SAAgB,CAAAC,EAAA5F,KAAA,SACM,GAAvByE,EAAmB,MACnBnQ,KAAK2Q,gBAAiB,CAAFW,EAAA5F,KAAA,SAEN,OAFM4F,EAAA9F,KAAA,EAAA8F,EAAA5F,KAAA,EAEA1L,KAAK2Q,gBAAe,OAApCR,EAAOmB,EAAAzF,KAAAyF,EAAA5F,KAAG,GAAH,aAAA4F,EAAA9F,KAAG,EAAH8F,EAAA7F,GAAA6F,EAAA,oBAKA,MAAXnB,EAAe,CAAAmB,EAAA5F,KAAA,SACL,OADK4F,EAAA5F,KAAA,GACC1L,KAAK0Q,gBAAe,QAApCP,EAAOmB,EAAAzF,KAAA,QAKNsE,GACDzQ,EAAO+M,WAAW,sBAAuB9M,EAAAA,GAAOsM,OAAOsF,cAAe,CAAC,GAItD,MAAjBvR,KAAKqR,WACDrR,KAAKyQ,WACLzQ,KAAKqR,SAAWlB,GAEhB7G,EAAAA,EAAAA,IAAetJ,KAAM,WAAYmQ,GAErCnQ,KAAKgR,KAAK,UAAWb,EAAS,OACjC,eAAAmB,EAAAxF,OAAA,SAGE9L,KAAKqR,UAAQ,yBAAAC,EAAAnF,OAAA,GAAAqF,EAAA,iB,GAKxB,CAAApR,IAAA,QAAAmJ,IACA,WAAS,IAAAhD,EAAA,KACL,OAAOkL,EAAAA,EAAAA,KAAK,WACR,OAAOlL,EAAKsK,SAASa,MAAK,SAACvB,GACvB,OAAOA,CACX,IAAG,SAAC5K,GAEA,GAAIA,EAAMyG,OAASrM,EAAAA,GAAOsM,OAAO0F,eAAiC,cAAhBpM,EAAMqM,MAGxD,MAAMrM,CACV,GACJ,GACJ,GAEA,CAAAnF,IAAA,0BAAAC,MAeM,SAAwBwR,G,kJAC1B,O,SAAM7R,KAAK6Q,SAAQ,YAGfgB,EAAS,GAAC,CAAAC,EAAApG,KAAA,oBAGH1L,KAAK+R,qBAAsB,CAAFD,EAAApG,KAAA,SAOT,OAJbsG,EAAsBhS,KAAK+R,qBAAoBD,EAAAtG,KAAA,EAAAsG,EAAApG,KAAA,EAI5BsG,EAAmB,OAA5B,GAANjN,EAAM+M,EAAAjG,OACPnD,IAAY3D,EAAOkN,UAAaJ,GAAM,CAAAC,EAAApG,KAAA,gBAAAoG,EAAAhG,OAAA,SAChC/G,EAAO3D,aAAW,eAAA0Q,EAAAhG,OAAA,uBAAAgG,EAAAtG,KAAA,GAAAsG,EAAArG,GAAAqG,EAAA,SAYzB9R,KAAK+R,uBAAyBC,EAAmB,CAAAF,EAAApG,KAAA,gBAAAoG,EAAAhG,OAAA,oBAAAgG,EAAApG,KAAA,gBAyCzD,OAlCFwG,EAAUxJ,IAEVyJ,GAA2BC,EAAAA,EAAAA,IAAkB,CAC/ChR,YAAapB,KAAKqS,QAAQ,iBAAkB,CAAC,GAC7CC,aAActS,KAAKuS,aAAab,MAAK,SAACvB,GAAO,OAAM,IAAI,IAAG,SAAC5K,GAAK,OAAMA,CAAK,MAC5EmM,MAAK,SAAAc,GAAkC,IAA/BpR,EAAWoR,EAAXpR,YAAakR,EAAYE,EAAZF,aACpB,GAAIA,EAKA,MAHIG,EAAKV,uBAAyBI,IAC9BM,EAAKV,qBAAuB,MAE1BO,EAGV,IAAML,EAAWvJ,IAOjB,OALAtH,EAAcmD,EAAAA,GAAUhD,KAAKH,GAAaoD,YACxBiO,EAAKxB,0BAA2B7P,EAAcqR,EAAKxB,yBAErEwB,EAAKxB,wBAA0B7P,EAC/BqR,EAAKC,oBAAoBtR,GAClB,CAAEA,YAAAA,EAAa8Q,QAAAA,EAASD,SAAAA,EACnC,IAEAjS,KAAK+R,qBAAuBI,EAG5BA,EAAyBvB,OAAM,SAACrL,GAExBkN,EAAKV,uBAAyBI,IAC9BM,EAAKV,qBAAuB,KAEpC,IAAGD,EAAApG,KAAA,GAEWyG,EAAwB,eAAAL,EAAAhG,OAAA,SAAAgG,EAAAjG,KAAEzK,aAAW,yBAAA0Q,EAAA3F,OAAA,GAAAwG,EAAA,kB,GACtD,CAAAvS,IAAA,OAAAC,MAEK,W,kJAQgB,OAPZuS,EAAS/C,IAGTgD,EAAgC,GAElCzR,EAAsB,KAAI0R,EAAAtH,KAAA,EAAAsH,EAAApH,KAAA,EAEN1L,KAAK+S,wBAAwB,IAAM/S,KAAKgT,gBAAkB,GAAE,OAAhF5R,EAAW0R,EAAAjH,KAAAiH,EAAApH,KAAG,GAAH,aAEe,OAFfoH,EAAAtH,KAAG,EAAHsH,EAAArH,GAAAqH,EAAA,SAEX9S,KAAKgR,KAAK,QAAO8B,EAAArH,IAASqH,EAAAhH,OAAA,kBAQ9B,GALA9L,KAAK0S,oBAAoBtR,GAGzBpB,KAAKgR,KAAK,OAAQ4B,EAAQxR,GAGtBA,IAAgBpB,KAAKkR,iBAAgB,CAAA4B,EAAApH,KAAA,SACR,OAA7B1L,KAAKgR,KAAK,UAAW4B,GAAQE,EAAAhH,OAAA,kBASjC,IAJ6B,IAAzB9L,KAAKsQ,SAASnN,QACdnD,KAAKsQ,SAASnN,MAAQ/B,EAAc,GAGpC6R,KAAKC,IAAclT,KAAKsQ,SAASnN,MAAU/B,GAAe,IAC1D1B,EAAO+I,KAAK,+DAAD4B,OAAiErK,KAAKsQ,SAASnN,MAAM,gBAAAkH,OAAgBjJ,EAAY,MAC5HpB,KAAKgR,KAAK,QAAStR,EAAOyT,UAAU,8BAA+BxT,EAAAA,GAAOsM,OAAO0F,cAAe,CAC5FvQ,YAAaA,EACbwQ,MAAO,YACPwB,oBAAqBpT,KAAKsQ,SAASnN,SAEvCnD,KAAKgR,KAAK,QAAS5P,QAInB,IAASwM,EAAa5N,KAAKsQ,SAASnN,MAAS,EAAGyK,GAAKxM,EAAawM,IAC9D5N,KAAKgR,KAAK,QAASpD,GA2EyB,OAtEvC5N,KAAKsQ,SAASnN,QAAW/B,IAClCpB,KAAKsQ,SAASnN,MAAQ/B,EAEtB4G,OAAOC,KAAKjI,KAAKsQ,UAAUrJ,SAAQ,SAAC7G,GAEhC,GAAY,UAARA,EAAJ,CAGA,IAAMiT,EAAmBC,EAAKhD,SAASlQ,GAKd,YAArBiT,GAIAjS,EAAciS,EAAmB,WAC1BC,EAAKhD,SAASlQ,E,CAE7B,MAI2B,IAA3BJ,KAAKkR,mBACLlR,KAAKkR,iBAAmB9P,EAAc,GAI1CpB,KAAKqQ,QAAQpJ,SAAQ,SAAC2K,GAClB,OAAQA,EAAM7Q,MACV,IAAK,KACD,IAAMH,EAAOgR,EAAMhR,KACf2S,EAASD,EAAKE,sBAAsB5S,GAAM8Q,MAAK,SAAChP,GAChD,OAAKA,GAAkC,MAAvBA,EAAQtB,aACxBkS,EAAKhD,SAAS,KAAO1P,GAAQ8B,EAAQtB,YACrCkS,EAAKtC,KAAKpQ,EAAM8B,GACT,MAH+C,IAI1D,IAAGkO,OAAM,SAACrL,GAAmB+N,EAAKtC,KAAK,QAASzL,EAAQ,IAExDsN,EAAQ3L,KAAKqM,GAEb,MAGJ,IAAK,SACD,IAAMzP,EAAS8N,EAAM9N,OACrBA,EAAOC,UAAYuP,EAAKpC,iBAAmB,EAC3CpN,EAAOG,QAAU7C,EAEjB,IAAMmS,EAASD,EAAKG,QAAQ3P,GAAQ4N,MAAK,SAAC3O,GAClB,IAAhBA,EAAKiC,QACTjC,EAAKkE,SAAQ,SAACO,GACV8L,EAAKhD,SAAS,KAAO9I,EAAIrG,WAAaqG,EAAIpG,YAC1CkS,EAAKhD,SAAS,KAAO9I,EAAIlF,iBAAmBkF,EAAIpG,YAChDkS,EAAKtC,KAAKlN,EAAQ0D,EACtB,GACJ,IAAGoJ,OAAM,SAACrL,GAAmB+N,EAAKtC,KAAK,QAASzL,EAAQ,IACxDsN,EAAQ3L,KAAKqM,GAKzB,IAEAvT,KAAKkR,iBAAmB9P,EAGxB0H,QAAQ4K,IAAIb,GAASnB,MAAK,WACtB4B,EAAKtC,KAAK,UAAW4B,EACzB,IAAGhC,OAAM,SAACrL,GAAY+N,EAAKtC,KAAK,QAASzL,EAAQ,IAAGuN,EAAAhH,OAAA,mCAAAgH,EAAA3G,OAAA,GAAAwH,EAAA,iB,GAKxD,CAAAvT,IAAA,mBAAAC,MACA,SAAiBe,GACbpB,KAAKkR,iBAAmB9P,EAAc,EAClCpB,KAAK4T,SAAW5T,KAAKyR,MAC7B,GAAC,CAAArR,IAAA,UAAAmJ,IAED,WACI,OAAOvJ,KAAKqR,QAChB,GAGA,CAAAjR,IAAA,gBAAAC,MACM,W,wJACKX,EAAO+M,WAAW,8CAA+C9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACzGC,UAAW,4BACb,wBAAAkH,EAAA1H,OAAA,GAAA2H,EAAA,I,GACL,CAAA1T,IAAA,aAAAC,MAEK,W,yIACc,O,SAAML,KAAK6Q,SAAQ,OAKZ,OALjBV,EAAO4D,EAAAlI,KAAAkI,EAAArI,KAAG,EAKa1L,KAAK0Q,gBAAe,OAA7B,GAAdsD,EAAcD,EAAAlI,KAChBsE,EAAQlK,UAAY+N,EAAe/N,QAAO,CAAA8N,EAAArI,KAAA,aAItC1L,KAAKyQ,WAAY,CAAFsD,EAAArI,KAAA,SAgBf,OAfA1L,KAAKqR,SAAW2C,EAGhBhU,KAAKkR,kBAAoB,EACzBlR,KAAKiU,iBAAmB,KACxBjU,KAAKkU,wBAA0B,KAC/BlU,KAAKoR,eAAiB,EACtBpR,KAAKsQ,SAASnN,OAAS,EACvBnD,KAAKiR,yBAA2B,KAChCjR,KAAK+R,qBAAuB,KAK5B/R,KAAKgR,KAAK,UAAWgD,EAAgB7D,GAAS4D,EAAArI,KAAA,GACxC9C,EAAM,GAAE,eAAAmL,EAAAjI,OAAA,SAEP9L,KAAKqR,UAAQ,QASE,MANpB9L,EAAQ7F,EAAOyT,UAAU,6BAA8BxT,EAAAA,GAAOsM,OAAO0F,cAAe,CACtFC,MAAO,UACPzB,QAASA,EACTgE,gBAAiBH,IAGrBhU,KAAKgR,KAAK,QAASzL,GACbA,EAAK,eAAAwO,EAAAjI,OAAA,SAGRqE,GAAO,yBAAA4D,EAAA5H,OAAA,GAAAiI,EAAA,S,GACjB,CAAAhU,IAAA,cAAAmJ,IAED,WAAe,IAAA8K,EAAA,KAKX,OAJArU,KAAK+S,wBAAwB,IAAM/S,KAAKgT,gBAAkB,GAAGtB,MAAK,SAACtQ,GAC/DiT,EAAK3B,oBAAoBtR,EAC7B,IAAG,SAACmE,GAAY,IAEiB,MAAzBvF,KAAKiU,iBAA4BjU,KAAKiU,kBAAmB,CACrE,GAAC,CAAA7T,IAAA,UAAAmJ,IAED,WACI,OAAwB,MAAhBvJ,KAAKsU,OACjB,EAACC,IAED,SAAYlU,GAAc,IAAAmU,EAAA,KAClBnU,IAAUL,KAAKsU,SACftU,KAAKsU,QAAUG,aAAY,WAAQD,EAAK/C,MAAQ,GAAGzR,KAAKgT,iBAEnDhT,KAAK0U,iBACN1U,KAAK0U,eAAiB1L,YAAW,WAC7BwL,EAAK/C,OAIL+C,EAAKE,eAAiB1L,YAAW,WAGxBwL,EAAKF,SAAWE,EAAK/C,OAG1B+C,EAAKE,eAAiB,IAC1B,GAAGF,EAAKxB,gBACZ,GAAG,MAGC3S,GAASL,KAAKsU,UACtBK,cAAc3U,KAAKsU,SACnBtU,KAAKsU,QAAU,KAEvB,GAAC,CAAAlU,IAAA,kBAAAmJ,IAED,WACI,OAAOvJ,KAAKmR,gBAChB,EAACoD,IAED,SAAoBlU,GAAa,IAAAuU,EAAA,KAC7B,GAAsB,kBAAXvU,GAAuBA,GAAS,GAAK8F,SAASqG,OAAOnM,KAAWA,EACvE,MAAM,IAAIqE,MAAM,4BAGpB1E,KAAKmR,iBAAmB9Q,EAEpBL,KAAKsU,UACLK,cAAc3U,KAAKsU,SACnBtU,KAAKsU,QAAUG,aAAY,WAAQG,EAAKnD,MAAQ,GAAGzR,KAAKmR,kBAEhE,GAAC,CAAA/Q,IAAA,sBAAAC,MAED,WAAmB,IAAAwU,EAAA,KACTC,EAAMpM,IAaZ,OAVKoM,EAAM9U,KAAKoR,eAAkB,EAAIpR,KAAKmR,mBACvCnR,KAAKoR,eAAiB0D,EACtB9U,KAAKkU,wBAA0BlU,KAAK+U,iBAAiBrD,MAAK,SAACtQ,GAIvD,OAH6B,MAAzByT,EAAKZ,kBAA4B7S,EAAcyT,EAAKZ,oBACpDY,EAAKZ,iBAAmB7S,GAErByT,EAAKZ,gBAChB,KAGGjU,KAAKkU,uBAChB,GAAC,CAAA9T,IAAA,sBAAAC,MAED,SAAoBe,GAEa,MAAzBpB,KAAKiU,kBAA4B7S,EAAcpB,KAAKiU,mBAGxDjU,KAAKoR,eAAiB1I,KAGO,MAAzB1I,KAAKiU,kBAA4B7S,EAAcpB,KAAKiU,oBACpDjU,KAAKiU,iBAAmB7S,EACxBpB,KAAKkU,wBAA0BpL,QAAQC,QAAQ3H,IAEvD,GAAC,CAAAhB,IAAA,qBAAAC,MAEK,SAAmBiC,EAAyBhB,EAAwB0T,G,wJAC/DhV,KAAKiV,oBAAoB3S,EAAmC,MAAjBhB,EAAyB,EAAGA,EAAe0T,GAAW,EAAG,OAAK,wBAAAE,EAAA/I,OAAA,GAAAgJ,EAAA,S,GACnH,CAAA/U,IAAA,sBAAAC,MAEK,SAAoBiC,EAAyBhB,EAAuB0T,EAAiBI,G,4IACvE,O,SAAMpV,KAAKwT,sBAAsBlR,GAAgB,OAApD,OAAPI,EAAO2S,EAAAxJ,MAGEnJ,EAAQpB,cAAe,IAAMA,GAAa,CAAA+T,EAAA3J,KAAA,eAAA2J,EAAAvJ,OAAA,SAAWpJ,GAAO,cAAA2S,EAAAvJ,OAAA,SAGpE,IAAIhD,SAAQ,SAACC,EAASuM,GACzB,IAAMC,EAAiC,GAEnCC,GAAO,EACLC,EAAc,WAChB,QAAID,IACJA,GAAO,EACPD,EAAYtO,SAAQ,SAACyO,GAAWA,GAAQ,KACjC,EACX,EAEMC,EAAe,SAACjT,GACdA,EAAQpB,cAAgBA,GACxBmU,KACJ1M,EAAQrG,EACZ,EAIA,GAHAkT,EAAKC,GAAGvT,EAAiBqT,GACzBJ,EAAYrO,MAAK,WAAQ0O,EAAKE,eAAexT,EAAiBqT,EAAe,IAEzEP,EAAa,CACb,IAAIW,EAAkBX,EAAYY,WAC9BC,EAAuB,KACrBC,EAAiB,SAAjBA,EAAwB9U,GAAmB,OAAI+U,EAAAP,OAAA,UAAAQ,EAAAA,EAAAA,KAAAC,MAAA,SAAAC,IAAA,IAAAC,EAAA,YAAAH,EAAAA,EAAAA,KAAAI,MAAA,SAAAC,GAAA,cAAAA,EAAAjL,KAAAiL,EAAA/K,MAAA,WAC7C8J,EAAM,CAAFiB,EAAA/K,KAAA,eAAA+K,EAAA3K,OAAA,iBAKR,OALQ2K,EAAA/K,KAAA,EAKF9C,EAAM,KAAK,OAEjB5I,KAAK0W,oBAAoBtB,EAAY7T,MAAMmQ,MAAK,SAAO7P,GAAK,OAAIsU,EAAAI,OAAA,UAAAH,EAAAA,EAAAA,KAAAC,MAAA,SAAAM,IAAA,IAAAC,EAAAzT,EAAA0T,EAAAzL,EAAA0L,EAAAC,EAAA,OAAAX,EAAAA,EAAAA,KAAAI,MAAA,SAAAQ,GAAA,cAAAA,EAAAxL,KAAAwL,EAAAtL,MAAA,WACxD8J,EAAM,CAAFwB,EAAAtL,KAAA,eAAAsL,EAAAlL,OAAA,sBAEJjK,GAASuT,EAAYvT,OAAK,CAAAmV,EAAAtL,KAAA,QAC1BqK,EAAkB3U,EAAY4V,EAAAtL,KAAA,gBAKZ,OALYsL,EAAAtL,KAAA,EAKN1L,KAAKiX,eAAe3U,GAAgB,OAA7C,KAALsU,EAAKI,EAAAnL,OACuB,MAArB+K,EAAMxV,YAAmB,CAAA4V,EAAAtL,KAAA,gBAAAsL,EAAAlL,OAAA,kBAOtB,MAAhBmK,IACAA,EAAeF,EAAkB,GACdX,EAAYY,aAC3BC,EAAeb,EAAYY,YAElC,aAEMC,GAAgB7U,GAAW,CAAA4V,EAAAtL,KAAA,aAC1B8J,EAAM,CAAFwB,EAAAtL,KAAA,gBAAAsL,EAAAlL,OAAA,kBAEM,OAFNkL,EAAAtL,KAAA,GAEY1L,KAAKkX,yBAAyBjB,GAAa,QAAzD9S,EAAK6T,EAAAnL,KACFgL,EAAK,EAAC,aAAEA,EAAK1T,EAAMM,aAAauB,QAAM,CAAAgS,EAAAtL,KAAA,SAG3C,IAFMN,EAAKjI,EAAMM,aAAaoT,IAGvBjW,OAAS0B,EAAe,CAAA0U,EAAAtL,KAAA,gBAAAsL,EAAAlL,OAAA,qBAG3BV,EAAG7J,OAAS6T,EAAY7T,MAAQ6J,EAAGvJ,QAAUuT,EAAYvT,MAAK,CAAAmV,EAAAtL,KAAA,aAC1D8J,EAAM,CAAFwB,EAAAtL,KAAA,gBAAAsL,EAAAlL,OAAA,kBAGQ,OAHRkL,EAAAtL,KAAA,GAGc1L,KAAKmX,mBAAmB/L,EAAGxK,KAAMU,GAAc,QAAxD,GAAPoB,EAAOsU,EAAAnL,MAGT4J,IAAe,CAAFuB,EAAAtL,KAAA,gBAAAsL,EAAAlL,OAAA,kBAiBb,OAdAiL,EAAS,WACT3L,EAAGzK,OAASyU,EAAYzU,MAAQyK,EAAGxJ,KAAOwT,EAAYxT,IAAMwJ,EAAG/K,MAAM+W,GAAGhC,EAAY/U,OACpF0W,EAAS,WACW,OAAZ3L,EAAGzK,MAAiByK,EAAG7J,OAAS6J,EAAGxJ,IAAMwJ,EAAG/K,MAAM0F,WAC1DgR,EAAS,aAIbzB,EAAO5V,EAAOyT,UAAU,2BAA4BxT,EAAAA,GAAOsM,OAAOoL,qBAAsB,CACpFC,UAAuB,aAAXP,GAAoC,cAAXA,EACrCA,OAAAA,EACAQ,YAAavX,KAAKwX,iBAAiBpM,GACnCxK,KAAM0B,EACNI,QAAAA,KACAsU,EAAAlL,OAAA,kBA/BqC+K,IAAIG,EAAAtL,KAAA,iBAoCrDuK,IAAee,EAAAtL,KAAA,qBAInB8J,EAAM,CAAFwB,EAAAtL,KAAA,gBAAAsL,EAAAlL,OAAA,kBACR9L,KAAKqJ,KAAK,QAAS6M,GAAgB,yBAAAc,EAAA7K,OAAA,GAAAwK,EAAA,SAEtC,IAAE,SAACpR,GACIiQ,GACJe,EAAKlN,KAAK,QAAS6M,EACvB,IAAG,wBAAAO,EAAAtK,OAAA,GAAAmK,EAAA,SACN,EAED,GAAId,EAAQ,OACZI,EAAKvM,KAAK,QAAS6M,GAEnBX,EAAYrO,MAAK,WACb0O,EAAKE,eAAe,QAASI,EACjC,G,CAGJ,GAAwB,kBAAblB,GAAyBA,EAAU,EAAG,CAC7C,IAAMyC,EAAQzO,YAAW,WACjByM,KACJH,EAAO5V,EAAOyT,UAAU,mBAAoBxT,EAAAA,GAAOsM,OAAOyL,QAAS,CAAE1C,QAASA,IAClF,GAAGA,GACCyC,EAAME,OAASF,EAAME,QAEzBpC,EAAYrO,MAAK,WAAQ0Q,aAAaH,EAAQ,G,CAEtD,KAAE,wBAAApC,EAAAlJ,OAAA,GAAA0L,EAAA,S,GACL,CAAAzX,IAAA,iBAAAC,MAEK,W,wJACKL,KAAK+S,wBAAwB,IAAE,wBAAA+E,EAAA3L,OAAA,GAAA4L,EAAA,S,GACzC,CAAA3X,IAAA,cAAAC,MAEK,W,qIACF,O,SAAML,KAAKuS,aAAY,OAER,OAFQyF,EAAAtM,KAAA,EAEF1L,KAAKqS,QAAQ,cAAe,CAAC,GAAG,OAAzC,OAANtN,EAAMiT,EAAAnM,KAAAmM,EAAAxM,KAAG,EAAHwM,EAAAlM,OAAA,SAEDvH,EAAAA,GAAUhD,KAAKwD,IAAO,cAAAiT,EAAAxM,KAAA,EAAAwM,EAAAvM,GAAAuM,EAAA,SAAAA,EAAAlM,OAAA,SAEtBpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,cACRnT,OAAAA,EAAQQ,MAAKyS,EAAAvM,MACf,yBAAAuM,EAAA7L,OAAA,GAAAgM,EAAA,iB,GAET,CAAA/X,IAAA,aAAAC,MAEK,SAAW+X,EAAyC1X,G,uIACtD,O,SAAMV,KAAKuS,aAAY,OACR,OADQ8F,EAAA3M,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CACnC7R,QAASP,KAAKsN,YAAY8K,GAC1B1X,SAAUV,KAAKsY,aAAa5X,KAC9B,OAEa,OALT6X,EAAMF,EAAAxM,KAAAwM,EAAA3M,KAAG,EAKM1L,KAAKqS,QAAQ,aAAckG,GAAO,OAA3C,OAANxT,EAAMsT,EAAAxM,KAAAwM,EAAA7M,KAAG,EAAH6M,EAAAvM,OAAA,SAEDvH,EAAAA,GAAUhD,KAAKwD,IAAO,eAAAsT,EAAA7M,KAAA,GAAA6M,EAAA5M,GAAA4M,EAAA,SAAAA,EAAAvM,OAAA,SAEtBpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,aACRK,OAAAA,EAAQxT,OAAAA,EAAQQ,MAAK8S,EAAA5M,MACvB,yBAAA4M,EAAAlM,OAAA,GAAAqM,EAAA,kB,GAET,CAAApY,IAAA,sBAAAC,MAEK,SAAoB+X,EAAyC1X,G,uIAC/D,O,SAAMV,KAAKuS,aAAY,OACR,OADQkG,EAAA/M,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CACnC7R,QAASP,KAAKsN,YAAY8K,GAC1B1X,SAAUV,KAAKsY,aAAa5X,KAC9B,OAEa,OALT6X,EAAME,EAAA5M,KAAA4M,EAAA/M,KAAG,EAKM1L,KAAKqS,QAAQ,sBAAuBkG,GAAO,OAApD,OAANxT,EAAM0T,EAAA5M,KAAA4M,EAAAjN,KAAG,EAAHiN,EAAA3M,OAAA,SAEDvH,EAAAA,GAAUhD,KAAKwD,GAAQP,YAAU,eAAAiU,EAAAjN,KAAA,GAAAiN,EAAAhN,GAAAgN,EAAA,SAAAA,EAAA3M,OAAA,SAEjCpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,sBACRK,OAAAA,EAAQxT,OAAAA,EAAQQ,MAAKkT,EAAAhN,MACvB,yBAAAgN,EAAAtM,OAAA,GAAAuM,EAAA,kB,GAET,CAAAtY,IAAA,UAAAC,MAEK,SAAQ+X,EAAyC1X,G,uIACnD,O,SAAMV,KAAKuS,aAAY,OACR,OADQoG,EAAAjN,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CACnC7R,QAASP,KAAKsN,YAAY8K,GAC1B1X,SAAUV,KAAKsY,aAAa5X,KAC9B,OAEa,OALT6X,EAAMI,EAAA9M,KAAA8M,EAAAjN,KAAG,EAKM1L,KAAKqS,QAAQ,UAAWkG,GAAO,OAAxC,OAANxT,EAAM4T,EAAA9M,KAAA8M,EAAAnN,KAAG,EAAHmN,EAAA7M,OAAA,UAED4D,EAAAA,EAAAA,IAAQ3K,IAAO,eAAA4T,EAAAnN,KAAA,GAAAmN,EAAAlN,GAAAkN,EAAA,SAAAA,EAAA7M,OAAA,SAEfpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,UACRK,OAAAA,EAAQxT,OAAAA,EAAQQ,MAAKoT,EAAAlN,MACvB,yBAAAkN,EAAAxM,OAAA,GAAAyM,EAAA,kB,GAET,CAAAxY,IAAA,eAAAC,MAEK,SAAa+X,EAAyCS,EAAgDnY,G,uIACxG,O,SAAMV,KAAKuS,aAAY,OACR,OADQuG,EAAApN,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CACnC7R,QAASP,KAAKsN,YAAY8K,GAC1B1X,SAAUV,KAAKsY,aAAa5X,GAC5BmY,SAAU/P,QAAQC,QAAQ8P,GAAUnH,MAAK,SAACqH,GAAC,OAAK1T,EAAAA,EAAAA,IAAS0T,EAAE,MAC7D,OACa,OALTR,EAAMO,EAAAjN,KAAAiN,EAAApN,KAAG,EAKM1L,KAAKqS,QAAQ,eAAgBkG,GAAO,OAA7C,OAANxT,EAAM+T,EAAAjN,KAAAiN,EAAAtN,KAAG,EAAHsN,EAAAhN,OAAA,UAED4D,EAAAA,EAAAA,IAAQ3K,IAAO,eAAA+T,EAAAtN,KAAA,GAAAsN,EAAArN,GAAAqN,EAAA,SAAAA,EAAAhN,OAAA,SAEfpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,eACRK,OAAAA,EAAQxT,OAAAA,EAAQQ,MAAKuT,EAAArN,MACvB,yBAAAqN,EAAA3M,OAAA,GAAA6M,EAAA,kB,GAIV,CAAA5Y,IAAA,mBAAAC,MACA,SAAiB+K,EAAiBxK,EAAeoV,GAAmB,IAAAiD,EAAA,KAChE,GAAY,MAARrY,GAAwC,MAAxB0E,EAAAA,EAAAA,IAAc1E,GAAgB,MAAM,IAAI8D,MAAM,sCAElE,IAAMK,EAA8BqG,EAwCpC,OArCY,MAARxK,GAAgBwK,EAAGxK,OAASA,GAC5BlB,EAAO+M,WAAW,2DAA4D9M,EAAAA,GAAOsM,OAAOsF,cAAe,CAAE2H,aAAc9N,EAAGxK,KAAMuY,aAAcvY,IAGtJmE,EAAOqU,KAAO,SAAOC,EAAmBrE,GAAgB,OAAImB,EAAA8C,OAAA,UAAA7C,EAAAA,EAAAA,KAAAC,MAAA,SAAAiD,IAAA,IAAA/B,EAAA7U,EAAA,OAAA0T,EAAAA,EAAAA,KAAAI,MAAA,SAAA+C,GAAA,cAAAA,EAAA/N,KAAA+N,EAAA7N,MAAA,OAiBxC,OAhBA,MAAZ2N,IAAoBA,EAAW,GACpB,MAAXrE,IAAmBA,EAAU,GAG7BuC,OAAcvT,EACD,IAAbqV,GAAgC,MAAdrD,IAClBuB,EAAc,CACV5W,KAAMyK,EAAGzK,KACTY,KAAM6J,EAAG7J,KACTM,MAAOuJ,EAAGvJ,MACVD,GAAIwJ,EAAGxJ,GACPvB,MAAO+K,EAAG/K,MACV2V,WAAAA,IAEPuD,EAAA7N,KAAA,EAEqB1L,KAAKiV,oBAAoB7J,EAAGxK,KAAMyY,EAAUrE,EAASuC,GAAY,OAA1E,GACE,OADT7U,EAAO6W,EAAA1N,OACuB,IAAbwN,EAAc,CAAAE,EAAA7N,KAAA,eAAA6N,EAAAzN,OAAA,SAAW,MAAI,OAWnD,OARD9L,KAAKsQ,SAAS,KAAOlF,EAAGxK,MAAQ8B,EAAQtB,YAEjB,IAAnBsB,EAAQQ,QACRxD,EAAO+M,WAAW,qBAAsB9M,EAAAA,GAAOsM,OAAOC,eAAgB,CAClE5J,gBAAiB8I,EAAGxK,KACpBI,YAAaoK,EACb1I,QAASA,IAEhB6W,EAAAzN,OAAA,SACMpJ,GAAO,yBAAA6W,EAAApN,OAAA,GAAAmN,EAAA,SACjB,EAEMvU,CACX,GAAC,CAAA3E,IAAA,kBAAAC,MAEK,SAAgBmZ,G,2IAClB,O,SAAMxZ,KAAKuS,aAAY,OACT,OADSkH,EAAA/N,KAAA,EACH5C,QAAQC,QAAQyQ,GAAmB9H,MAAK,SAAAgI,GAAC,OAAIhK,EAAAA,EAAAA,IAAQgK,EAAE,IAAC,OAGxD,OAHdC,EAAKF,EAAA5N,KAEa,OADlBT,EAAKpL,KAAKiL,UAAUjK,YAAYwY,IAC/BlY,gBAAyB8J,EAAG9J,cAAgB,GAAImY,EAAA/N,KAAA,EAC7B1L,KAAK+S,wBAAwB,IAAM,EAAI/S,KAAKgT,iBAAgB,OAErE,OAFX5R,EAAWqY,EAAA5N,KAAA4N,EAAAjO,KAAG,GAAHiO,EAAA/N,KAAG,GAEG1L,KAAKqS,QAAQ,kBAAmB,CAAEmH,kBAAmBG,IAAQ,QAAtE,OAAJ/Y,EAAI6Y,EAAA5N,KAAA4N,EAAA3N,OAAA,SACH9L,KAAKwX,iBAAiBpM,EAAIxK,EAAMQ,IAAY,QAGZ,MAHYqY,EAAAjO,KAAA,GAAAiO,EAAAhO,GAAAgO,EAAA,UAE7CA,EAAAhO,GAAOzK,YAAcoK,EACrBqO,EAAAhO,GAAOnJ,gBAAkB8I,EAAGxK,KAAK6Y,EAAAhO,GAAA,yBAAAgO,EAAAtN,OAAA,GAAAyN,EAAA,mB,GAG9C,CAAAxZ,IAAA,yBAAAC,MAEK,SAAuBW,G,8IACL,O,SAAMA,EAAW,OA4BI,OA5BnC6Y,EAAMC,EAAAjO,KAENT,EAAU,CAAC,EAEjB,CAAC,OAAQ,MAAMnE,SAAQ,SAAC7G,GACD,MAAfyZ,EAAOzZ,KACXgL,EAAGhL,GAAO0I,QAAQC,QAAQ8Q,EAAOzZ,IAAMsR,MAAK,SAACzP,GAAC,OAAMA,EAAI8X,EAAKzM,YAAYrL,GAAI,IAAI,IACrF,IAEA,CAAC,WAAY,WAAY,eAAgB,uBAAwB,SAASgF,SAAQ,SAAC7G,GAC5D,MAAfyZ,EAAOzZ,KACXgL,EAAGhL,GAAO0I,QAAQC,QAAQ8Q,EAAOzZ,IAAMsR,MAAK,SAACzP,GAAC,OAAMA,EAAIsC,EAAAA,GAAUhD,KAAKU,GAAI,IAAI,IACnF,IAEA,CAAC,QAAQgF,SAAQ,SAAC7G,GACK,MAAfyZ,EAAOzZ,KACXgL,EAAGhL,GAAO0I,QAAQC,QAAQ8Q,EAAOzZ,IAAMsR,MAAK,SAACzP,GAAC,OAAY,MAALA,EAAaA,EAAG,IAAI,IAC7E,IAEI4X,EAAO5Y,aACPmK,EAAGnK,WAAajB,KAAKiL,UAAUhK,WAAW4Y,EAAO5Y,aAGrD,CAAC,QAAQgG,SAAQ,SAAC7G,GACK,MAAfyZ,EAAOzZ,KACXgL,EAAGhL,GAAO0I,QAAQC,QAAQ8Q,EAAOzZ,IAAMsR,MAAK,SAACzP,GAAC,OAAMA,GAAIyN,EAAAA,EAAAA,IAAQzN,GAAI,IAAI,IAC5E,IAAG6X,EAAArO,GAEIzL,KAAKiL,UAAS6O,EAAApO,KAAA,IAA0B0G,EAAAA,EAAAA,IAAkBhH,GAAG,eAAA0O,EAAAlO,GAAAkO,EAAAjO,KAAAiO,EAAAhO,OAAA,SAAAgO,EAAArO,GAA9CrJ,mBAAkBuJ,KAAAmO,EAAArO,GAAAqO,EAAAlO,KAAA,yBAAAkO,EAAA3N,OAAA,GAAA6N,EAAA,S,GAC3C,CAAA5Z,IAAA,aAAAC,MAEK,SAAWyD,G,4IACJ,O,SAAMA,EAAM,OAkBQ,OAlB7BA,EAAMmW,EAAApO,KAEA9G,EAAc,CAAC,EAEC,MAAlBjB,EAAOvD,UACPwE,EAAOxE,QAAUP,KAAKsN,YAAYxJ,EAAOvD,UAG7C,CAAC,YAAa,UAAU0G,SAAQ,SAAC7G,GACH,MAAhB0D,EAAQ1D,KAClB2E,EAAO3E,GAAa0D,EAAQ1D,GAChC,IAEA,CAAC,YAAa,WAAW6G,SAAQ,SAAC7G,GACJ,MAAhB0D,EAAQ1D,KAClB2E,EAAO3E,GAAO8Z,EAAK5B,aAAmBxU,EAAQ1D,IAClD,IAAG6Z,EAAAxO,GAEIzL,KAAKiL,UAASgP,EAAAvO,KAAA,IAAc0G,EAAAA,EAAAA,IAAkBrN,GAAO,eAAAkV,EAAArO,GAAAqO,EAAApO,KAAAoO,EAAAnO,OAAA,SAAAmO,EAAAxO,GAAtC3H,OAAM6H,KAAAsO,EAAAxO,GAAAwO,EAAArO,KAAA,yBAAAqO,EAAA9N,OAAA,GAAAgO,EAAA,S,GAC/B,CAAA/Z,IAAA,OAAAC,MAEK,SAAKW,EAA6CN,G,uIACpD,O,SAAMV,KAAKuS,aAAY,OACR,OADQ6H,EAAA1O,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CACnCpR,YAAahB,KAAKqa,uBAAuBrZ,GACzCN,SAAUV,KAAKsY,aAAa5X,KAC9B,OAEa,OALT6X,EAAM6B,EAAAvO,KAAAuO,EAAA1O,KAAG,EAKM1L,KAAKqS,QAAQ,OAAQkG,GAAO,OAArC,OAANxT,EAAMqV,EAAAvO,KAAAuO,EAAA5O,KAAG,EAAH4O,EAAAtO,OAAA,UAED4D,EAAAA,EAAAA,IAAQ3K,IAAO,eAAAqV,EAAA5O,KAAA,GAAA4O,EAAA3O,GAAA2O,EAAA,SAAAA,EAAAtO,OAAA,SAEfpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,OACRK,OAAAA,EAAQxT,OAAAA,EAAQQ,MAAK6U,EAAA3O,MACvB,yBAAA2O,EAAAjO,OAAA,GAAAmO,EAAA,kB,GAET,CAAAla,IAAA,cAAAC,MAEK,SAAYW,G,uIACd,O,SAAMhB,KAAKuS,aAAY,OACR,OADQgI,EAAA7O,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CACnCpR,YAAahB,KAAKqa,uBAAuBrZ,KAC3C,OAEa,OAJTuX,EAAMgC,EAAA1O,KAAA0O,EAAA7O,KAAG,EAIM1L,KAAKqS,QAAQ,cAAekG,GAAO,OAA5C,OAANxT,EAAMwV,EAAA1O,KAAA0O,EAAA/O,KAAG,EAAH+O,EAAAzO,OAAA,SAEDvH,EAAAA,GAAUhD,KAAKwD,IAAO,eAAAwV,EAAA/O,KAAA,GAAA+O,EAAA9O,GAAA8O,EAAA,SAAAA,EAAAzO,OAAA,SAEtBpM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC5EC,OAAQ,cACRK,OAAAA,EAAQxT,OAAAA,EAAQQ,MAAKgV,EAAA9O,MACvB,yBAAA8O,EAAApO,OAAA,GAAAqO,EAAA,kB,GAET,CAAApa,IAAA,cAAAC,MAEK,SAAY+X,G,qIACE,O,SAAMA,EAAa,OAKnB,MAJc,kBAD9BA,EAAaqC,EAAA5O,OAETnM,EAAOoF,mBAAmB,8BAA+B,OAAQsT,GACpEqC,EAAA/O,KAAA,EAEqB1L,KAAK0a,YAAYtC,GAAc,OAKpD,OAJc,OADT7X,EAAOka,EAAA5O,OAETnM,EAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CAC9EC,UAAW,eAAFtC,OAAkB0E,KAAKC,UAAUoJ,GAAe,OAEhEqC,EAAA3O,OAAA,SACMvL,GAAO,wBAAAka,EAAAtO,OAAA,GAAAwO,EAAA,S,GACjB,CAAAva,IAAA,YAAAC,MAEK,SAAUua,EAAqEC,G,8IACjF,O,SAAM7a,KAAKuS,aAAY,OAED,OAFCuI,EAAApP,KAAA,EAEKkP,EAAmB,OAO9C,GAPDA,EAAmBE,EAAAjP,KAGfzK,GAAe,IAEbmX,EAAiC,CACnCsC,sBAAuBA,KAGvBhW,EAAAA,EAAAA,IAAY+V,EAAqB,IAAK,CAAFE,EAAApP,KAAA,SACpC6M,EAAOpX,UAAYyZ,EAAoBE,EAAApP,KAAA,iBAGjB,OAHiBoP,EAAAtP,KAAA,GAAAsP,EAAApP,KAAA,GAGX1L,KAAKsY,aAAasC,GAAoB,QAA9DrC,EAAO7X,SAAQoa,EAAAjP,MACXhH,EAAAA,EAAAA,IAAY0T,EAAO7X,YACnBU,EAAc+E,SAASoS,EAAO7X,SAASkE,UAAU,GAAI,KACxDkW,EAAApP,KAAA,iBAAAoP,EAAAtP,KAAA,GAAAsP,EAAArP,GAAAqP,EAAA,UAEDpb,EAAOoF,mBAAmB,kCAAmC,sBAAuB8V,GAAqB,eAAAE,EAAAhP,OAAA,UAI1G2F,EAAAA,EAAAA,KAAK,kBAAW0E,EAAA4E,OAAA,UAAA3E,EAAAA,EAAAA,KAAAC,MAAA,SAAA2E,IAAA,IAAA7X,EAAA8X,EAAArN,EAAAxC,EAAA9J,EAAA4Z,EAAAC,EAAA,YAAA/E,EAAAA,EAAAA,KAAAI,MAAA,SAAA4E,GAAA,cAAAA,EAAA5P,KAAA4P,EAAA1P,MAAA,OACL,OADK0P,EAAA1P,KAAA,EACC1L,KAAKqS,QAAQ,WAAYkG,GAAO,OAAzC,GAGE,OAHPpV,EAAKiY,EAAAvP,MAGM,CAAAuP,EAAA1P,KAAA,YAKW,MAApB6M,EAAOpX,UAAiB,CAAAia,EAAA1P,KAAA,WACsB,MAA1C1L,KAAKsQ,SAAS,KAAOiI,EAAOpX,WAAkB,CAAAia,EAAA1P,KAAA,eAAA0P,EAAAtP,OAAA,SAAW,MAAI,UAI9C,MAAnByM,EAAO7X,SAAgB,CAAA0a,EAAA1P,KAAA,cACnBtK,EAAcpB,KAAKsQ,SAASnN,OAAK,CAAAiY,EAAA1P,KAAA,gBAAA0P,EAAAtP,OAAA,SAAW,MAAI,eAAAsP,EAAAtP,OAAA,cAIjD9H,GAAS,YAIhB6W,EAAqB,CAAFO,EAAA1P,KAAA,SACftK,EAAsB,KACjBwM,EAAI,EAAC,aAAEA,EAAIzK,EAAMM,aAAauB,QAAM,CAAAoW,EAAA1P,KAAA,SACT,GACV,OADhBN,EAAKjI,EAAMM,aAAamK,IACvBxM,YAAmB,CAAAga,EAAA1P,KAAA,SACtBN,EAAG9J,cAAgB,EAAE8Z,EAAA1P,KAAA,oBAEM,MAApBN,EAAG9J,cAAqB,CAAA8Z,EAAA1P,KAAA,YACZ,MAAftK,EAAmB,CAAAga,EAAA1P,KAAA,SACL,OADK0P,EAAA1P,KAAA,GACC1L,KAAK+S,wBAAwB,IAAM,EAAI/S,KAAKgT,iBAAgB,QAAhF5R,EAAWga,EAAAvP,KAAA,SAIXvK,EAAiBF,EAAcgK,EAAGhK,YAAe,IAChC,IAAKE,EAAgB,GAC1C8J,EAAG9J,cAAgBA,EAAc,QAbMsM,IAAGwN,EAAA1P,KAAA,iBAkBgE,OAD5GwP,EAAoBlb,KAAKiL,UAAUtH,sBAAsBR,IAClDM,aAAeyX,EAAazX,aAAaiD,KAAI,SAAC0E,GAAuB,OAAK+P,EAAK3D,iBAAiBpM,EAAG,IAAEgQ,EAAAtP,OAAA,SAC3GoP,GAAY,eAAAE,EAAAtP,OAAA,SAGhB9L,KAAKiL,UAAU9H,MAAMA,IAAM,yBAAAiY,EAAAjP,OAAA,GAAA6O,EAAA,SAErC,GAAE,CAAEK,SAAUrb,QAAO,yBAAA8a,EAAA3O,OAAA,GAAAmP,EAAA,mB,GACzB,CAAAlb,IAAA,WAAAC,MAED,SAASua,GACL,OAAwB5a,KAAKub,UAAUX,GAAqB,EAChE,GAAC,CAAAxa,IAAA,2BAAAC,MAED,SAAyBua,GACrB,OAAwC5a,KAAKub,UAAUX,GAAqB,EAChF,GAAC,CAAAxa,IAAA,iBAAAC,MAEK,SAAeiC,G,4IACjB,O,SAAMtC,KAAKuS,aAAY,OACL,OADKiJ,EAAA9P,KAAA,EACCpJ,EAAe,OAEuC,OAF9EA,EAAekZ,EAAA3P,KAET0M,EAAS,CAAEjW,gBAAiBtC,KAAKiL,UAAUrK,KAAK0B,GAAiB,IAAOkZ,EAAA1P,OAAA,UAEvE2F,EAAAA,EAAAA,KAAK,kBAAW0E,EAAAsF,OAAA,UAAArF,EAAAA,EAAAA,KAAAC,MAAA,SAAAqF,IAAA,IAAA3W,EAAAqG,EAAAhK,EAAAE,EAAA,OAAA8U,EAAAA,EAAAA,KAAAI,MAAA,SAAAmF,GAAA,cAAAA,EAAAnQ,KAAAmQ,EAAAjQ,MAAA,OACJ,OADIiQ,EAAAjQ,KAAA,EACE1L,KAAKqS,QAAQ,iBAAkBkG,GAAO,OAA/C,GAEE,OAFRxT,EAAM4W,EAAA9P,MAEM,CAAA8P,EAAAjQ,KAAA,WAC+B,MAAzC1L,KAAKsQ,SAAS,KAAOhO,GAAwB,CAAAqZ,EAAAjQ,KAAA,eAAAiQ,EAAA7P,OAAA,SACtC,MAAI,cAAA6P,EAAA7P,OAAA,cAER9H,GAAS,OAGiC,GAE/B,OAFhBoH,EAAKpL,KAAKiL,UAAUpH,oBAAoBkB,IAEvC3D,YAAmB,CAAAua,EAAAjQ,KAAA,SACtBN,EAAG9J,cAAgB,EAAEqa,EAAAjQ,KAAA,oBAEM,MAApBN,EAAG9J,cAAqB,CAAAqa,EAAAjQ,KAAA,SACX,OADWiQ,EAAAjQ,KAAA,GACL1L,KAAK+S,wBAAwB,IAAM,EAAI/S,KAAKgT,iBAAgB,QAAhF5R,EAAWua,EAAA9P,MAGbvK,EAAiBF,EAAcgK,EAAGhK,YAAe,IAChC,IAAKE,EAAgB,GAC1C8J,EAAG9J,cAAgBA,EAAc,eAAAqa,EAAA7P,OAAA,SAG9B9L,KAAKwX,iBAAiBpM,IAAG,yBAAAuQ,EAAAxP,OAAA,GAAAuP,EAAA,SACnC,GAAE,CAAEL,SAAUrb,QAAO,wBAAAwb,EAAArP,OAAA,GAAAyP,EAAA,S,GACzB,CAAAxb,IAAA,wBAAAC,MAEK,SAAsBiC,G,4IACxB,O,SAAMtC,KAAKuS,aAAY,OAEL,OAFKsJ,EAAAnQ,KAAA,EAECpJ,EAAe,OAEuC,OAF9EA,EAAeuZ,EAAAhQ,KAET0M,EAAS,CAAEjW,gBAAiBtC,KAAKiL,UAAUrK,KAAK0B,GAAiB,IAAOuZ,EAAA/P,OAAA,UAEvE2F,EAAAA,EAAAA,KAAK,kBAAW0E,EAAA2F,OAAA,UAAA1F,EAAAA,EAAAA,KAAAC,MAAA,SAAA0F,IAAA,IAAAhX,EAAArC,EAAAtB,EAAAE,EAAA,OAAA8U,EAAAA,EAAAA,KAAAI,MAAA,SAAAwF,GAAA,cAAAA,EAAAxQ,KAAAwQ,EAAAtQ,MAAA,OACJ,OADIsQ,EAAAtQ,KAAA,EACE1L,KAAKqS,QAAQ,wBAAyBkG,GAAO,OAAtD,GAEE,OAFRxT,EAAMiX,EAAAnQ,MAEM,CAAAmQ,EAAAtQ,KAAA,WAC+B,MAAzC1L,KAAKsQ,SAAS,KAAOhO,GAAwB,CAAA0Z,EAAAtQ,KAAA,eAAAsQ,EAAAlQ,OAAA,SACtC,MAAI,cAAAkQ,EAAAlQ,OAAA,cAER9H,GAAS,UAII,MAApBe,EAAO5D,UAAiB,CAAA6a,EAAAtQ,KAAA,eAAAsQ,EAAAlQ,OAAA,cAAW9H,GAAS,OAEF,GAEnB,OAFrBtB,EAAU1C,KAAKiL,UAAUvI,QAAQqC,IAE3B3D,YAAmB,CAAA4a,EAAAtQ,KAAA,SAC3BhJ,EAAQpB,cAAgB,EAAE0a,EAAAtQ,KAAA,oBAEM,MAAzBhJ,EAAQpB,cAAqB,CAAA0a,EAAAtQ,KAAA,SAChB,OADgBsQ,EAAAtQ,KAAA,GACV1L,KAAK+S,wBAAwB,IAAM,EAAI/S,KAAKgT,iBAAgB,QAAhF5R,EAAW4a,EAAAnQ,MAGbvK,EAAiBF,EAAcsB,EAAQtB,YAAe,IACrC,IAAKE,EAAgB,GAC1CoB,EAAQpB,cAAgBA,EAAc,eAAA0a,EAAAlQ,OAAA,SAGnCpJ,GAAO,yBAAAsZ,EAAA7P,OAAA,GAAA4P,EAAA,SACjB,GAAE,CAAEV,SAAUrb,QAAO,wBAAA6b,EAAA1P,OAAA,GAAA8P,EAAA,S,GACzB,CAAA7b,IAAA,UAAAC,MAEK,SAAQyD,G,uIACV,O,SAAM9D,KAAKuS,aAAY,OACR,OADQ2J,EAAAxQ,KAAA,GACF0G,EAAAA,EAAAA,IAAkB,CAAEtO,OAAQ9D,KAAKmc,WAAWrY,KAAU,OAClD,OADnByU,EAAM2D,EAAArQ,KAAAqQ,EAAAxQ,KAAG,EACgB1L,KAAKqS,QAAQ,UAAWkG,GAAO,OAG3D,OAHGxV,EAAImZ,EAAArQ,MACL5E,SAAQ,SAACO,GACS,MAAfA,EAAIrD,UAAmBqD,EAAIrD,SAAU,EAC7C,IAAG+X,EAAApQ,OAAA,SACIlM,EAAU4C,QAAQxC,KAAKiL,UAAU/G,UAAU1D,KAAKR,KAAKiL,WAArDrL,CAAiEmD,IAAK,yBAAAmZ,EAAA/P,OAAA,GAAAiQ,EAAA,S,GAChF,CAAAhc,IAAA,gBAAAC,MAEK,W,+HACF,O,SAAML,KAAKuS,aAAY,cAAA8J,EAAAvQ,OAAA,SAChB9L,KAAKqS,QAAQ,gBAAiB,CAAC,IAAG,wBAAAgK,EAAAlQ,OAAA,GAAAmQ,EAAA,S,GAC5C,CAAAlc,IAAA,eAAAC,MAEK,SAAaK,G,qIACJ,O,SAAMA,EAAQ,OAAjB,KAEiB,kBAFzBA,EAAQ6b,EAAA1Q,OAE6BnL,EAAW,GAAC,CAAA6b,EAAA7Q,KAAA,SAK3B,OAJdhL,EAAW,GACXhB,EAAOoF,mBAAmB,mBAAoB,WAAYpE,GAC7D6b,EAAA7Q,KAAA,EAEuB1L,KAAK+S,wBAAwB,IAAM,EAAI/S,KAAKgT,iBAAgB,OAE3C,OAFrC5R,EAAWmb,EAAA1Q,MACfzK,GAAeV,GACG,IAAKU,EAAc,GAAImb,EAAAzQ,OAAA,SAClC9L,KAAKiL,UAAUvK,SAASU,IAAY,eAAAmb,EAAAzQ,OAAA,SAGxC9L,KAAKiL,UAAUvK,SAASA,IAAS,yBAAA6b,EAAApQ,OAAA,GAAAqQ,EAAA,S,GAC3C,CAAApc,IAAA,cAAAC,MAGK,SAAY0K,G,qIAEM,O,kBAAM/K,KAAKyc,aAAa1R,GAAK,OAAhC,GACE,OADTxK,EAAOmc,EAAA7Q,MACM,CAAA6Q,EAAAhR,KAAA,eAAAgR,EAAA5Q,OAAA,SAAW,MAAI,cAAA4Q,EAAA5Q,OAAA,SAC3B,IAAIjB,EAAS7K,KAAMO,EAASwK,IAAK,UAAA2R,EAAAlR,KAAA,EAAAkR,EAAAjR,GAAAiR,EAAA,SAEpCA,EAAAjR,GAAMO,OAASrM,EAAAA,GAAOsM,OAAOC,eAAc,CAAAwQ,EAAAhR,KAAA,gBAAAgR,EAAA5Q,OAAA,SAAW,MAAI,eAAA4Q,EAAA5Q,OAAA,SACvD,MAAI,yBAAA4Q,EAAAvQ,OAAA,GAAAwQ,EAAA,iB,GAElB,CAAAvc,IAAA,eAAAC,MAEK,SAAa0K,G,uIAEC,O,SAAM/K,KAAKuS,aAAY,OAkBD,OAlBhCpC,EAAOyM,EAAA/Q,MAGAgR,YACTnd,EAAO+M,WACH,+BACA9M,EAAAA,GAAOsM,OAAOS,sBACd,CAAEC,UAAW,MAAOwD,QAASA,EAAQpF,OAKvC/J,EAAc,CAChBY,GAAIuO,EAAQ0M,WACZlc,KAAO,cAAe2K,EAAAA,EAAAA,IAASP,GAAMnG,UAAU,IAClDgY,EAAApR,KAAA,EAAAoR,EAAAnR,GAGUzL,KAAKiL,UAAS2R,EAAAlR,KAAA,EAAmB1L,KAAK2L,KAAK3K,GAAY,cAAA4b,EAAAhR,GAAAgR,EAAA/Q,KAAA+Q,EAAA9Q,OAAA,SAAA8Q,EAAAnR,GAAxC2B,YAAWzB,KAAAiR,EAAAnR,GAAAmR,EAAAhR,KAAA,WAAAgR,EAAApR,KAAA,GAAAoR,EAAA7Q,GAAA6Q,EAAA,SAE7BA,EAAA7Q,GAAMC,OAASrM,EAAAA,GAAOsM,OAAOC,eAAc,CAAA0Q,EAAAlR,KAAA,gBAAAkR,EAAA9Q,OAAA,SAAW,MAAI,cAAA8Q,EAAA7Q,GAAA,yBAAA6Q,EAAAzQ,OAAA,GAAA2Q,EAAA,kB,GAGrE,CAAA1c,IAAA,cAAAC,MAEK,SAAY0K,G,qIACP,O,SAAMA,EAAI,OAAb,OAAJA,EAAIgS,EAAAlR,KAAAkR,EAAAvR,KAAG,EAAHuR,EAAAjR,OAAA,SAIOhD,QAAQC,QAAQ/I,KAAKiL,UAAU1K,QAAQwK,KAAM,UAAAgS,EAAAvR,KAAA,EAAAuR,EAAAtR,GAAAsR,EAAA,WAGhDlY,EAAAA,EAAAA,IAAYkG,GAAO,CAAFgS,EAAArR,KAAA,eAAAqR,EAAAtR,GAAA,QAQR,MALI,kBAAVV,GACPrL,EAAOoF,mBAAmB,mBAAoB,OAAQiG,GAG1DgS,EAAArR,KAAA,GACuB1L,KAAKgd,YAAYjS,GAAK,QAA/B,GAARkS,EAAQF,EAAAlR,KACC,CAAFkR,EAAArR,KAAA,gBAAAqR,EAAAjR,OAAA,SAAW,MAAI,QAErB,OAFqBiR,EAAArR,KAAA,GAEfuR,EAAShY,aAAY,eAAA8X,EAAAjR,OAAA,SAAAiR,EAAAlR,MAAA,yBAAAkR,EAAA5Q,OAAA,GAAA+Q,EAAA,iB,GACrC,CAAA9c,IAAA,gBAAAC,MAEK,SAAcE,G,6IACN,O,SAAMA,EAAO,OAKC,OALxBA,EAAO4c,EAAAtR,KACPtL,EAAUP,KAAKiL,UAAU1K,QAAQA,GAE3B6c,EAAc7c,EAAQqE,UAAU,GAAGH,cAAgB,gBAAe0Y,EAAAzR,KAAA,EAE1C1L,KAAKyc,aAAaW,GAAY,OAAvC,GAAfC,EAAeF,EAAAtR,KACC,CAAFsR,EAAAzR,KAAA,gBAAAyR,EAAArR,OAAA,SAAW,MAAI,QAGd,OAHcqR,EAAA1R,GAGvBoB,EAAAA,GAAQsQ,EAAAzR,KAAA,GAAO1L,KAAK2L,KAAK,CACjC/J,GAAIyb,EACJ1c,KAAO,cAAe2K,EAAAA,EAAAA,IAAS8R,GAAaxY,UAAU,KACxD,QAHO,GAGPuY,EAAAvR,GAAAuR,EAAAtR,QAHEe,GAAQ,EAAHuQ,EAAA1R,IAAA0R,EAAAvR,KAMC5G,OAAS,KAAOT,EAAAA,GAAUhD,KAAKqL,EAAMhF,MAAM,EAAG,KAAKwP,GAAG,IAAG,CAAA+F,EAAAzR,KAAA,gBAAAyR,EAAArR,OAAA,SAAW,MAAI,QAGlF,MAFAc,EAAQA,EAAMhF,MAAM,KAGV5C,OAAS,IAAE,CAAAmY,EAAAzR,KAAA,gBAAAyR,EAAArR,OAAA,SAAW,MAAI,QAMpC,GAHM9G,EAAST,EAAAA,GAAUhD,KAAKqL,EAAMhF,MAAM,EAAG,KAAKpD,WAClDoI,EAAQA,EAAMhF,MAAM,MAGhB5C,EAAS4H,EAAM5H,QAAM,CAAAmY,EAAAzR,KAAA,gBAAAyR,EAAArR,OAAA,SAAW,MAAI,QAK3B,OAHPf,GAAOL,EAAAA,EAAAA,IAAakC,EAAMhF,MAAM,EAAG5C,IAEzCmY,EAAAzR,KAAA,GACmB1L,KAAK0a,YAAY3P,GAAK,QAA/B,GAAAoS,EAAAtR,MACEtL,EAAO,CAAA4c,EAAAzR,KAAA,gBAAAyR,EAAArR,OAAA,SAAW,MAAI,eAAAqR,EAAArR,OAAA,SAE3Bf,GAAI,yBAAAoS,EAAAhR,OAAA,GAAAmR,EAAA,S,GACd,CAAAld,IAAA,YAAAC,MAEK,SAAUkd,G,6IACiB,GAAzBN,EAAqB,OACrBpY,EAAAA,EAAAA,IAAY0Y,GAAgB,CAAFC,EAAA9R,KAAA,SAMF,OAJlBnL,EAAUP,KAAKiL,UAAU1K,QAAQgd,GAEjCH,EAAc7c,EAAQqE,UAAU,GAAGH,cAAgB,gBAAe+Y,EAAA9R,KAAA,EAE1C1L,KAAKyc,aAAaW,GAAY,OAAvC,GAAfC,EAAeG,EAAA3R,KACC,CAAF2R,EAAA9R,KAAA,eAAA8R,EAAA1R,OAAA,SAAW,MAAI,OAEnCmR,EAAW,IAAIpS,EAAS7K,KAAMqd,EAAiB,IAAK9c,GAASid,EAAA9R,KAAA,iBAIlD,OAJkD8R,EAAA9R,KAAA,GAI5C1L,KAAKgd,YAAYO,GAAc,QAAhDN,EAAQO,EAAA3R,KAAA,QAGG,OAHH2R,EAAA9R,KAAG,GAGMuR,EAASQ,YAAW,QAA7B,GACE,OADR9P,EAAM6P,EAAA3R,MACM,CAAA2R,EAAA9R,KAAA,gBAAA8R,EAAA1R,OAAA,SAAW,MAAI,eAAA0R,EAAA1R,OAAA,SAE1B6B,EAAOG,KAAG,yBAAA0P,EAAArR,OAAA,GAAAuR,EAAA,S,GACpB,CAAAtd,IAAA,UAAAC,MAED,SAAQ6X,EAAgBK,GACpB,OAAO7Y,EAAO+M,WAAWyL,EAAS,mBAAoBvY,EAAAA,GAAOsM,OAAO0R,gBAAiB,CAAEhR,UAAWuL,GACtG,GAAC,CAAA9X,IAAA,cAAAC,MAED,SAAYuR,GACR5R,KAAK4T,QAAW5T,KAAKqQ,QAAQvM,QAAO,SAAC8Z,GAAC,OAAKA,EAAEC,UAAU,IAAE7Y,OAAS,CACtE,GAAC,CAAA5E,IAAA,aAAAC,MAED,SAAWuR,GACP5R,KAAK4T,QAAW5T,KAAKqQ,QAAQvM,QAAO,SAAC8Z,GAAC,OAAKA,EAAEC,UAAU,IAAE7Y,OAAS,CACtE,GAAC,CAAA5E,IAAA,oBAAAC,MAED,SAAkBgI,EAAsBe,EAAoBC,GACxD,IAAMuI,EAAQ,IAAI1I,EAAMd,EAAYC,GAAYe,EAAUC,GAI1D,OAHArJ,KAAKqQ,QAAQnJ,KAAK0K,GAClB5R,KAAK8d,YAAYlM,GAEV5R,IACX,GAAC,CAAAI,IAAA,KAAAC,MAED,SAAGgI,EAAsBe,GACrB,OAAOpJ,KAAK+d,kBAAkB1V,EAAWe,GAAU,EACvD,GAAC,CAAAhJ,IAAA,OAAAC,MAED,SAAKgI,EAAsBe,GACvB,OAAOpJ,KAAK+d,kBAAkB1V,EAAWe,GAAU,EACvD,GAAC,CAAAhJ,IAAA,OAAAC,MAGD,SAAKgI,GAAyC,QAAA2V,EAAA,KAAAC,EAAAC,UAAAlZ,OAAhBmZ,EAAgB,IAAA3X,MAAAyX,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAhBD,EAAgBC,EAAA,GAAAF,UAAAE,GAC1C,IAAIrZ,GAAS,EAETsZ,EAAwB,GAExBC,EAAWlW,EAAYC,GAoB3B,OAnBArI,KAAKqQ,QAAUrQ,KAAKqQ,QAAQvM,QAAO,SAAC8N,GAChC,OAAIA,EAAMzI,MAAQmV,IAElBtV,YAAW,WACP4I,EAAMxI,SAASmV,MAAMP,EAAMG,EAC/B,GAAG,GAEHpZ,GAAS,GAEL6M,EAAMvI,OACNgV,EAAQnX,KAAK0K,IACN,GAIf,IAEAyM,EAAQpX,SAAQ,SAAC2K,GAAYoM,EAAKQ,WAAW5M,EAAQ,IAE9C7M,CACX,GAAC,CAAA3E,IAAA,gBAAAC,MAED,SAAcgI,GACV,IAAKA,EAAa,OAAOrI,KAAKqQ,QAAQrL,OAEtC,IAAIsZ,EAAWlW,EAAYC,GAC3B,OAAOrI,KAAKqQ,QAAQvM,QAAO,SAAC8N,GACxB,OAAQA,EAAMzI,MAAQmV,CAC1B,IAAGtZ,MACP,GAAC,CAAA5E,IAAA,YAAAC,MAED,SAAUgI,GACN,GAAiB,MAAbA,EACA,OAAOrI,KAAKqQ,QAAQ3J,KAAI,SAACkL,GAAK,OAAKA,EAAMxI,QAAQ,IAGrD,IAAIkV,EAAWlW,EAAYC,GAC3B,OAAOrI,KAAKqQ,QACPvM,QAAO,SAAC8N,GAAK,OAAMA,EAAMzI,MAAQmV,CAAQ,IACzC5X,KAAI,SAACkL,GAAK,OAAKA,EAAMxI,QAAQ,GACtC,GAAC,CAAAhJ,IAAA,MAAAC,MAED,SAAIgI,EAAsBe,GAAmB,IAAAqV,EAAA,KACzC,GAAgB,MAAZrV,EACA,OAAOpJ,KAAK0e,mBAAmBrW,GAGnC,IAAMgW,EAAwB,GAE1BM,GAAQ,EAERL,EAAWlW,EAAYC,GAW3B,OAVArI,KAAKqQ,QAAUrQ,KAAKqQ,QAAQvM,QAAO,SAAC8N,GAChC,OAAIA,EAAMzI,MAAQmV,GAAY1M,EAAMxI,UAAYA,MAC5CuV,IACJA,GAAQ,EACRN,EAAQnX,KAAK0K,IACN,GACX,IAEAyM,EAAQpX,SAAQ,SAAC2K,GAAY6M,EAAKD,WAAW5M,EAAQ,IAE9C5R,IACX,GAAC,CAAAI,IAAA,qBAAAC,MAED,SAAmBgI,GAAqB,IAAAuW,EAAA,KAChCP,EAAwB,GAC5B,GAAiB,MAAbhW,EACAgW,EAAUre,KAAKqQ,QAEfrQ,KAAKqQ,QAAU,OACZ,CACH,IAAMiO,EAAWlW,EAAYC,GAC7BrI,KAAKqQ,QAAUrQ,KAAKqQ,QAAQvM,QAAO,SAAC8N,GAChC,OAAIA,EAAMzI,MAAQmV,IAClBD,EAAQnX,KAAK0K,IACN,EACX,G,CAKJ,OAFAyM,EAAQpX,SAAQ,SAAC2K,GAAYgN,EAAKJ,WAAW5M,EAAQ,IAE9C5R,IACX,IAAC,EAAAI,IAAA,eAAAC,MA9pCD,WAII,OAHwB,MAApBuP,IACAA,EAAmB,IAAIhQ,GAEpBgQ,CACX,GAEA,CAAAxP,IAAA,aAAAC,MACA,SAAkB8P,GACd,OAAOoC,EAAAA,EAAAA,GAAuB,MAAXpC,EAAmB,YAAaA,EACvD,KAACL,CAAA,CA3JqB,CAAQM,EAAAA,I,qVCnhB5B1Q,GAAS,IAAIC,EAAAA,GAAOF,GAKpBof,GAAW,CAAE,OAAQ,eAE3B,SAASC,GAAW5G,EAAgB3S,EAAYgT,GAG5C,GAAe,SAAXL,GAAqB3S,EAAMyG,OAASrM,EAAAA,GAAOsM,OAAOgM,aAAc,CAChE,IAAM2F,EAAIrY,EAAMA,MAChB,GAAIqY,GAAKA,EAAEmB,QAAQjS,MAAM,cAAejI,EAAAA,EAAAA,IAAY+Y,EAAEjd,MAClD,OAAOid,EAAEjd,KAGbjB,GAAO+M,WAAW,wCAAyC9M,EAAAA,GAAOsM,OAAOC,eAAgB,CACrF3G,MAAAA,EAAO5E,KAAM,M,CAIrB,IAAIoe,EAAUxZ,EAAMwZ,QAChBxZ,EAAMyG,OAASrM,EAAAA,GAAOsM,OAAOgM,cAAgB1S,EAAMA,OAAyC,kBAAzBA,EAAMA,MAAMwZ,QAC/EA,EAAUxZ,EAAMA,MAAMwZ,QACQ,kBAAhBxZ,EAAMyZ,KACpBD,EAAUxZ,EAAMyZ,KACsB,kBAAxBzZ,EAAM0Z,eACpBF,EAAUxZ,EAAM0Z,cAEpBF,GAAWA,GAAW,IAAIta,cAE1B,IAAMzD,EAAcuX,EAAOvX,aAAeuX,EAAOiB,kBAoCjD,MAjCIuF,EAAQjS,MAAM,kDACdpN,GAAO+M,WAAW,oDAAqD9M,EAAAA,GAAOsM,OAAOiT,mBAAoB,CACrG3Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAKnB+d,EAAQjS,MAAM,kBACdpN,GAAO+M,WAAW,8BAA+B9M,EAAAA,GAAOsM,OAAOkT,cAAe,CAC1E5Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAKnB+d,EAAQjS,MAAM,wCACdpN,GAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOmT,wBAAyB,CAChF7Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAKnB+d,EAAQjS,MAAM,0BACdpN,GAAO+M,WAAW,gDAAiD9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACpGnH,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAInB6d,GAASvW,QAAQ4P,IAAW,GAAK6G,EAAQjS,MAAM,iFAC/CpN,GAAO+M,WAAW,4EAA6E9M,EAAAA,GAAOsM,OAAOoT,wBAAyB,CAClI9Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAIjBuE,CACV,CAEA,SAASkS,GAAMzC,GACX,OAAO,IAAIlM,SAAQ,SAASC,GACxBC,WAAWD,EAASiM,EACxB,GACJ,CAEA,SAASsK,GAAUC,GACf,GAAIA,EAAQha,MAAO,CAEf,IAAMA,EAAa,IAAIb,MAAM6a,EAAQha,MAAMwZ,SAG3C,MAFAxZ,EAAMyG,KAAOuT,EAAQha,MAAMyG,KAC3BzG,EAAM5E,KAAO4e,EAAQha,MAAM5E,KACrB4E,C,CAGV,OAAOga,EAAQxa,MACnB,CAEA,SAASya,GAAanf,GAClB,OAAIA,EAAgBA,EAAMoE,cACnBpE,CACX,CAEA,IAAMof,GAAoB,CAAC,EAEdC,GAAc,SAAAC,IAAA3P,EAAAA,EAAAA,GAAA0P,EAAAC,GAAA,IAAA1P,GAAAC,EAAAA,EAAAA,GAAAwP,GAKvB,SAAAA,EAAYE,EAAuB9U,EAA2B+U,GAAgC,IAAAvf,EAK1F,IAL0FT,EAAAA,EAAAA,GAAA,KAAA6f,GAC1FhgB,GAAOI,SAAS,gBAAD4f,EAAA,KAAA3f,iBAAA,EAAa2f,GAE5Bpf,EAAA2P,EAAAtE,KAAA,MAEIiU,IAAqBH,GACrB,MAAM,IAAI/a,MAAM,8EAiBnB,OAdD4E,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,WAAYwK,GAEX,MAAlB+U,IAA0BA,EAAiB,GAEhB,kBAApBA,IACPvW,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,WAAYA,EAAKwK,SAASG,UAAU1K,QAAQsf,KACjEvW,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,SAAU,OAEG,kBAApBuf,IACdvW,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,SAAUuf,IAC/BvW,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,WAAY,OAGjCZ,GAAOoF,mBAAmB,2BAA4B,iBAAkB+a,GAC3Evf,CACL,CA6IC,OA7IAH,EAAAA,EAAAA,GAAAuf,EAAA,EAAAtf,IAAA,UAAAC,MAED,SAAQyK,GACJ,OAAOpL,GAAO+M,WAAW,0CAA2C9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACrGC,UAAW,WAEnB,GAAC,CAAAvM,IAAA,mBAAAC,MAED,WACI,OAAO,IAAIyf,GAAuBL,GAAmBzf,KAAK8K,SAAU9K,KAAK+f,UAAY/f,KAAKggB,OAC9F,GAAC,CAAA5f,IAAA,aAAAC,MAED,WAAU,IAAAkG,EAAA,KACN,OAAIvG,KAAK+f,SACEjX,QAAQC,QAAQ/I,KAAK+f,UAGzB/f,KAAK8K,SAASmV,KAAK,eAAgB,IAAIvO,MAAK,SAACwO,GAMhD,OALIA,EAASlb,QAAUuB,EAAKyZ,QACxBtgB,GAAO+M,WAAW,oBAAsBlG,EAAKyZ,OAAQrgB,EAAAA,GAAOsM,OAAOS,sBAAuB,CACtFC,UAAW,eAGZpG,EAAKuE,SAASG,UAAU1K,QAAQ2f,EAAS3Z,EAAKyZ,QACzD,GACJ,GAAC,CAAA5f,IAAA,2BAAAC,MAED,SAAyBW,GAA2C,IAAAyR,EAAA,KAChEzR,GAAc4C,EAAAA,EAAAA,IAAY5C,GAE1B,IAAMmf,EAAcngB,KAAKiF,aAAayM,MAAK,SAACnR,GAExC,OADIA,IAAWA,EAAUA,EAAQkE,eAC1BlE,CACX,IAKA,GAA4B,MAAxBS,EAAYW,SAAkB,CAC9B,IAAMye,GAAWxc,EAAAA,EAAAA,IAAY5C,GAC7Bof,EAAS7e,KAAO4e,EAChBnf,EAAYW,SAAW3B,KAAK8K,SAASuV,YAAYD,E,CAcrD,OAXsB,MAAlBpf,EAAYY,KACZZ,EAAYY,GAAKkH,QAAQC,QAAQ/H,EAAYY,IAAI8P,MAAK,SAAO9P,GAAE,OAAIuU,GAAA1D,OAAA,UAAA2D,EAAAA,EAAAA,KAAAC,MAAA,SAAAjK,IAAA,IAAA7L,EAAA,OAAA6V,EAAAA,EAAAA,KAAAI,MAAA,SAAAjL,GAAA,cAAAA,EAAAC,KAAAD,EAAAG,MAAA,UACrD,MAAN9J,EAAU,CAAA2J,EAAAG,KAAA,eAAAH,EAAAO,OAAA,SAAW,MAAI,OACb,OADaP,EAAAG,KAAA,EACP1L,KAAK8K,SAAS4P,YAAY9Y,GAAG,OAGlD,OAFc,OADTrB,EAAOgL,EAAAM,OAETnM,GAAOoF,mBAAmB,qCAAsC,QAASlD,GAC5E2J,EAAAO,OAAA,SACMvL,GAAO,wBAAAgL,EAAAY,OAAA,GAAAC,EAAA,SACjB,MAGEgG,EAAAA,EAAAA,IAAkB,CACrBhH,IAAIgH,EAAAA,EAAAA,IAAkBpR,GACtBsf,OAAQH,IACTzO,MAAK,SAAAc,GAAmB,IAAhBpH,EAAEoH,EAAFpH,GAAIkV,EAAM9N,EAAN8N,OAEI,MAAXlV,EAAG7J,KACC6J,EAAG7J,KAAKkD,gBAAkB6b,GAC1B5gB,GAAOoF,mBAAmB,wBAAyB,cAAe9D,GAGtEoK,EAAG7J,KAAO+e,EAGd,IAAM3G,EAAclH,EAAK3H,SAAS/K,YAAawgB,mBAAmBnV,EAAI,CAAE7J,MAAM,IAE9E,OAAOkR,EAAK3H,SAASmV,KAAK,sBAAuB,CAAEtG,IAASjI,MAAK,SAAC9Q,GAC9D,OAAOA,CACX,IAAG,SAAC2E,GACA,OAAOuZ,GAAW,kBAAmBvZ,EAAOoU,EAChD,GACJ,GACJ,GAAC,CAAAvZ,IAAA,kBAAAC,MAED,SAAgBW,GACZ,OAAOtB,GAAO+M,WAAW,sCAAuC9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACjGC,UAAW,mBAEnB,GAAC,CAAAvM,IAAA,kBAAAC,MAEK,SAAgBW,G,+IAEE,O,SAAMhB,KAAK8K,SAASiI,wBAAwB,IAAM,EAAI/S,KAAK8K,SAASkI,iBAAgB,OAG3F,OAHP5R,EAAWqM,EAAA5B,KAAA4B,EAAA/B,KAAG,EAGD1L,KAAKwgB,yBAAyBxf,GAAY,OAMlD,OANLJ,EAAI6M,EAAA5B,KAAA4B,EAAAjC,KAAG,EAAHiC,EAAA/B,KAAG,GAMI+F,EAAAA,EAAAA,KAAK,kBAAW0E,GAAA7C,OAAA,UAAA8C,EAAAA,EAAAA,KAAAC,MAAA,SAAA9I,IAAA,IAAAnC,EAAA,OAAAgL,EAAAA,EAAAA,KAAAI,MAAA,SAAAtJ,GAAA,cAAAA,EAAA1B,KAAA0B,EAAAxB,MAAA,OACd,OADcwB,EAAAxB,KAAA,EACR1L,KAAK8K,SAASmM,eAAerW,GAAK,OAA3C,GACG,QADLwK,EAAE8B,EAAArB,MACO,CAAAqB,EAAAxB,KAAA,eAAAwB,EAAApB,OAAA,cAAW9H,GAAS,cAAAkJ,EAAApB,OAAA,SAC5B9L,KAAK8K,SAAS0M,iBAAiBpM,EAAIxK,EAAMQ,IAAY,wBAAA8L,EAAAf,OAAA,GAAAoB,EAAA,SAC/D,GAAE,CAAE8N,SAAUrb,KAAK8K,WAAW,cAAA2C,EAAA3B,OAAA,SAAA2B,EAAA5B,MAAA,QAEK,MAFL4B,EAAAjC,KAAA,GAAAiC,EAAAhC,GAAAgC,EAAA,SAEzBA,EAAAhC,GAAOnJ,gBAAkB1B,EAAK6M,EAAAhC,GAAA,yBAAAgC,EAAAtB,OAAA,GAAA+C,EAAA,kB,GAG3C,CAAA9O,IAAA,cAAAC,MAEK,SAAY0e,G,wIAEE,OADVpe,EAA6B,kBAAboe,GAAyBvP,EAAAA,EAAAA,IAAYuP,GAAUA,EAAO5P,EAAAzD,KAAA,EACtD1L,KAAKiF,aAAY,OAEhC,OAFD1E,EAAO4O,EAAAtD,KAAAsD,EAAAzD,KAAG,EAEH1L,KAAK8K,SAASmV,KAAK,gBAAiB,EAAEvQ,EAAAA,EAAAA,IAAQ/O,GAAOJ,EAAQkE,gBAAgB,cAAA0K,EAAArD,OAAA,SAAAqD,EAAAtD,MAAA,wBAAAsD,EAAAhD,OAAA,GAAAmD,EAAA,S,GAC7F,CAAAlP,IAAA,qBAAAC,MAEK,SAAmB0e,G,wIAEL,OADVpe,EAA6B,kBAAboe,GAAyBvP,EAAAA,EAAAA,IAAYuP,GAAUA,EAAOtP,EAAA/D,KAAA,EACtD1L,KAAKiF,aAAY,OAGhC,OAHD1E,EAAOkP,EAAA5D,KAAA4D,EAAA/D,KAAG,EAGH1L,KAAK8K,SAASmV,KAAK,WAAY,CAAE1f,EAAQkE,eAAeiL,EAAAA,EAAAA,IAAQ/O,KAAQ,cAAA8O,EAAA3D,OAAA,SAAA2D,EAAA5D,MAAA,wBAAA4D,EAAAtD,OAAA,GAAAwD,EAAA,S,GACxF,CAAAvP,IAAA,iBAAAC,MAEK,SAAeogB,EAAyBC,EAA8CrgB,G,+IAEtE,O,SAAMsgB,GAAAA,EAAkBC,aAAaH,EAAQC,EAAOrgB,GAAO,SAAC0K,GAC1E,OAAOsJ,EAAKvJ,SAAS4P,YAAY3P,EACrC,IAAE,OAEc,OAJV8V,EAASvP,EAAAzF,KAAAyF,EAAA5F,KAAG,EAII1L,KAAKiF,aAAY,OAEhC,OAFD1E,EAAO+Q,EAAAzF,KAAAyF,EAAA5F,KAAG,EAEH1L,KAAK8K,SAASmV,KAAK,uBAAwB,CACpD1f,EAAQkE,cACRsK,KAAKC,UAAU2R,GAAAA,EAAkBG,WAAWD,EAAUJ,OAAQC,EAAOG,EAAUxgB,UACjF,cAAAiR,EAAAxF,OAAA,SAAAwF,EAAAzF,MAAA,wBAAAyF,EAAAnF,OAAA,GAAAqF,EAAA,S,GACL,CAAApR,IAAA,SAAAC,MAEK,SAAO0gB,G,wIAGO,OAFVjW,EAAW9K,KAAK8K,SAAQgH,EAAApG,KAAA,EAER1L,KAAKiF,aAAY,OAA1B,OAAP1E,EAAOuR,EAAAjG,KAAAiG,EAAAhG,OAAA,SAENhB,EAASmV,KAAK,yBAA0B,CAAE1f,EAAQkE,cAAesc,EAAU,QAAO,wBAAAjP,EAAA3F,OAAA,GAAAwG,EAAA,S,KAC5F+M,CAAA,CA1KsB,CAAQsB,GAAAA,GA6K7BlB,GAAuB,SAAAmB,IAAAjR,EAAAA,EAAAA,GAAA8P,EAAAmB,GAAA,IAAAC,GAAAhR,EAAAA,EAAAA,GAAA4P,GAAA,SAAAA,IAAA,OAAAjgB,EAAAA,EAAAA,GAAA,KAAAigB,GAAAoB,EAAA3C,MAAA,KAAAL,UAAA,CAgBxB,OAhBwB/d,EAAAA,EAAAA,GAAA2f,EAAA,EAAA1f,IAAA,kBAAAC,MACzB,SAAgBW,GAA2C,IAAAwT,EAAA,KACvD,OAAOxU,KAAKwgB,yBAAyBxf,GAAa0Q,MAAK,SAAC9Q,GACpD,MAA4B,CACxBA,KAAMA,EACNiB,MAAO,KACPF,SAAU,KACVH,SAAU,KACVb,KAAM,KACNN,MAAO,KACP4F,QAAS,KACT3E,cAAe,EACfC,KAAM,KACN6X,KAAM,SAAC9X,GAA6B,OAAOkT,EAAK1J,SAASqM,mBAAmBvW,EAAMU,EAAgB,EAE1G,GACJ,KAACwe,CAAA,CAhBwB,CAAQJ,IAmB/ByB,GAAuD,CACzDlb,SAAS,EAAMtF,MAAM,EAAMgB,UAAU,EAAMH,UAAS,EAAMK,OAAO,EAAMD,IAAI,EAAMvB,OAAO,EACxFU,MAAM,EAAME,YAAY,EACxBS,cAAc,EAAMD,sBAAsB,GAGjC2f,GAAgB,SAAAC,IAAArR,EAAAA,EAAAA,GAAAoR,EAAAC,GAAA,IAAAC,GAAApR,EAAAA,EAAAA,GAAAkR,GAiBzB,SAAAA,EAAYtT,EAA+BqC,GAAoB,IAAAyE,GAAA/U,EAAAA,EAAAA,GAAA,KAAAuhB,GAC3D1hB,GAAOI,SAAS,gBAADshB,EAAA,KAAArhB,iBAAA,EAAaqhB,GAE5B,IAAIG,EAAgDpR,EA4BlC,OAzBI,MAAlBoR,IACAA,EAAiB,IAAIzY,SAAQ,SAACC,EAASuM,GACnCtM,YAAW,WACP4L,EAAKlE,gBAAgBgB,MAAK,SAACvB,GACvBpH,EAAQoH,EACZ,IAAG,SAAC5K,GACA+P,EAAO/P,EACX,GACJ,GAAG,EACP,KAGJqP,EAAA0M,EAAA3V,KAAA,KAAM4V,GAGDzT,IAAOA,GAAMiD,EAAAA,EAAAA,IAAwB6D,EAAK7U,YAAa,aAA1CgR,IAEE,kBAATjD,GACPxE,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAoE,GAAO,aAAa5M,OAAOwZ,OAAO,CAC5C1T,IAAKA,MAGTxE,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAoE,GAAO,aAAc5M,OAAOwZ,QAAO5d,EAAAA,EAAAA,IAAYkK,KAGjE8G,EAAK6M,QAAU,GAAG7M,CACtB,CA6SC,OA7SAzU,EAAAA,EAAAA,GAAAihB,EAAA,EAAAhhB,IAAA,SAAAmJ,IAvCD,WAII,OAH4B,MAAxBvJ,KAAK0hB,kBACL1hB,KAAK0hB,gBAAkB,CAAC,GAErB1hB,KAAK0hB,eAChB,GAAC,CAAAthB,IAAA,gBAAAC,MAwCD,WAAa,IAAAwU,EAAA,KAST,OARK7U,KAAK2hB,OAAsB,gBAC5B3hB,KAAK2hB,OAAsB,cAAI3hB,KAAK4hB,yBAGpC5Y,YAAW,WACP6L,EAAK8M,OAAsB,cAAI,IACnC,GAAG,IAEA3hB,KAAK2hB,OAAsB,aACtC,GAAC,CAAAvhB,IAAA,yBAAAC,MAEK,W,wIACF,O,SAAMoX,GAAM,GAAE,OAIA,OAFVxR,EAAU,KAAI6M,EAAAtH,KAAA,EAAAsH,EAAApH,KAAA,EAEE1L,KAAKigB,KAAK,cAAe,IAAI,OAA7Cha,EAAO6M,EAAAjH,KAAAiH,EAAApH,KAAG,GAAH,aAGO,OAHPoH,EAAAtH,KAAG,EAAHsH,EAAArH,GAAAqH,EAAA,SAAAA,EAAAtH,KAAG,GAAHsH,EAAApH,KAAG,GAGU1L,KAAKigB,KAAK,cAAe,IAAI,QAA7Cha,EAAO6M,EAAAjH,KAAAiH,EAAApH,KAAG,GAAH,cAAAoH,EAAAtH,KAAG,GAAHsH,EAAAlH,GAAAkH,EAAA,qBAIA,MAAX7M,EAAe,CAAA6M,EAAApH,KAAA,SAC+E,OAAxF6G,GAAaxB,EAAAA,EAAAA,IAA4C/Q,KAAKD,YAAa,cAAa+S,EAAAtH,KAAA,GAAAsH,EAAAhH,OAAA,SAEnFyG,EAAWhO,EAAAA,GAAUhD,KAAK0E,GAASzB,aAAW,eAAAsO,EAAAtH,KAAA,GAAAsH,EAAA/G,GAAA+G,EAAA,UAAAA,EAAAhH,OAAA,SAE9CpM,GAAO+M,WAAW,2BAA4B9M,EAAAA,GAAOsM,OAAO0F,cAAe,CAC9E1L,QAASA,EACT2L,MAAO,iBACPiQ,YAAW/O,EAAA/G,MACb,eAAA+G,EAAAhH,OAAA,SAIHpM,GAAO+M,WAAW,2BAA4B9M,EAAAA,GAAOsM,OAAO0F,cAAe,CAC9EC,MAAO,eACT,yBAAAkB,EAAA3G,OAAA,GAAAwH,EAAA,iC,GACL,CAAAvT,IAAA,YAAAC,MAED,SAAUwf,GACN,OAAO,IAAIH,GAAcD,GAAmBzf,KAAM6f,EACtD,GAAC,CAAAzf,IAAA,qBAAAC,MAED,SAAmBwf,GACf,OAAO7f,KAAK8hB,UAAUjC,GAAgBkC,kBAC1C,GAAC,CAAA3hB,IAAA,eAAAC,MAED,WAAY,IAAAuV,EAAA,KACR,OAAO5V,KAAKigB,KAAK,eAAgB,IAAIvO,MAAK,SAACwO,GACvC,OAAOA,EAASxZ,KAAI,SAACsb,GAAC,OAAKpM,EAAK3K,UAAU1K,QAAQyhB,EAAE,GACxD,GACJ,GAAC,CAAA5hB,IAAA,OAAAC,MAED,SAAK6X,EAAgBK,GAAkB,IAAAhC,EAAA,KAC7B0L,EAAU,CACZ/J,OAAQA,EACRK,OAAQA,EACR2J,GAAKliB,KAAKyhB,UACVU,QAAS,OAGbniB,KAAKgR,KAAK,QAAS,CACfoR,OAAQ,UACRH,SAASI,EAAAA,EAAAA,IAASJ,GAClBnX,SAAU9K,OAKd,IAAMsiB,EAAS,CAAE,cAAe,mBAAoBha,QAAQ4P,IAAW,EACvE,GAAIoK,GAAStiB,KAAK2hB,OAAOzJ,GACrB,OAAOlY,KAAK2hB,OAAOzJ,GAGvB,IAAMnT,GAAS6J,EAAAA,EAAAA,IAAU5O,KAAKuiB,WAAYxT,KAAKC,UAAUiT,GAAU3C,IAAW5N,MAAK,SAAC3M,GAQhF,OAPAwR,EAAKvF,KAAK,QAAS,CACfoR,OAAQ,WACRH,QAASA,EACTO,SAAUzd,EACV+F,SAAUyL,IAGPxR,CAEX,IAAG,SAACQ,GAQA,MAPAgR,EAAKvF,KAAK,QAAS,CACfoR,OAAQ,WACR7c,MAAOA,EACP0c,QAASA,EACTnX,SAAUyL,IAGRhR,CACV,IAUA,OAPI+c,IACAtiB,KAAK2hB,OAAOzJ,GAAUnT,EACtBiE,YAAW,WACPuN,EAAKoL,OAAOzJ,GAAU,IAC1B,GAAG,IAGAnT,CACX,GAAC,CAAA3E,IAAA,iBAAAC,MAED,SAAe6X,EAAgBK,GAC3B,OAAQL,GACJ,IAAK,iBACD,MAAO,CAAE,kBAAmB,IAEhC,IAAK,cACD,MAAO,CAAE,eAAgB,IAE7B,IAAK,aACD,MAAO,CAAE,iBAAkB,CAAEsH,GAAajH,EAAOhY,SAAUgY,EAAO7X,WAEtE,IAAK,sBACD,MAAO,CAAE,0BAA2B,CAAE8e,GAAajH,EAAOhY,SAAUgY,EAAO7X,WAE/E,IAAK,UACD,MAAO,CAAE,cAAe,CAAE8e,GAAajH,EAAOhY,SAAUgY,EAAO7X,WAEnE,IAAK,eACD,MAAO,CAAE,mBAAoB,CAAE8e,GAAajH,EAAOhY,SAAUgY,EAAOM,SAAUN,EAAO7X,WAEzF,IAAK,kBACD,MAAO,CAAE,yBAA0B,CAAE6X,EAAOiB,oBAEhD,IAAK,WACD,OAAIjB,EAAO7X,SACA,CAAE,uBAAwB,CAAE6X,EAAO7X,WAAY6X,EAAOsC,sBACtDtC,EAAOpX,UACP,CAAE,qBAAsB,CAAEoX,EAAOpX,YAAaoX,EAAOsC,sBAEzD,KAEX,IAAK,iBACD,MAAO,CAAE,2BAA4B,CAAEtC,EAAOjW,kBAElD,IAAK,wBACD,MAAO,CAAE,4BAA6B,CAAEiW,EAAOjW,kBAEnD,IAAK,OAED,MAAO,CAAE,WAAY,EADMyO,EAAAA,EAAAA,IAAgG/Q,KAAKD,YAAa,qBACtHwgB,CAAmBhI,EAAOvX,YAAa,CAAEO,MAAM,IAASgX,EAAO7X,WAG1F,IAAK,cAED,MAAO,CAAE,kBAAmB,EADDqQ,EAAAA,EAAAA,IAAgG/Q,KAAKD,YAAa,qBAC/GwgB,CAAmBhI,EAAOvX,YAAa,CAAEO,MAAM,MAGjF,IAAK,UAID,OAHIgX,EAAOzU,QAAmC,MAAzByU,EAAOzU,OAAOvD,UAC/BgY,EAAOzU,OAAOvD,QAAUif,GAAajH,EAAOzU,OAAOvD,UAEhD,CAAE,cAAe,CAAEgY,EAAOzU,SAMzC,OAAO,IACX,GAAC,CAAA1D,IAAA,UAAAC,MAEK,SAAQ6X,EAAgBK,G,6IAGX,SAAXL,GAAgC,gBAAXA,EAAwB,CAAArE,EAAAnI,KAAA,QAChB,KAAvBN,EAAKmN,EAAOvX,cACG,MAAXoK,EAAGrK,OAAgBwD,EAAAA,GAAUhD,KAAK6J,EAAGrK,MAAMgF,SAAQ,CAAA8N,EAAAnI,KAAA,WAElC,MAAnBN,EAAG1J,cAAmD,MAA3B0J,EAAG3J,qBAA4B,CAAAoS,EAAAnI,KAAA,QAC1C,OAD0CmI,EAAAnI,KAAA,EACpC1L,KAAKyiB,aAAY,OACX,OADtBC,EAAO7O,EAAAhI,MACDnK,cAAwD,MAAhCghB,EAAQjhB,wBAExC8W,GAAS3U,EAAAA,EAAAA,IAAY2U,IACdvX,aAAc4C,EAAAA,EAAAA,IAAYwH,UAC1BmN,EAAOvX,YAAYD,MAC7B,OAWF,OAJC,OAFNod,EAAOne,KAAK2iB,eAAezK,EAASK,KAGtC7Y,GAAO+M,WAAWyL,EAAS,mBAAoBvY,EAAAA,GAAOsM,OAAO0R,gBAAiB,CAAEhR,UAAWuL,IAC9FrE,EAAArI,KAAA,GAAAqI,EAAAnI,KAAA,GAEgB1L,KAAKigB,KAAK9B,EAAK,GAAIA,EAAK,IAAG,eAAAtK,EAAA/H,OAAA,SAAA+H,EAAAhI,MAAA,eAAAgI,EAAArI,KAAA,GAAAqI,EAAApI,GAAAoI,EAAA,UAAAA,EAAA/H,OAAA,SAEjCgT,GAAW5G,EAAMrE,EAAApI,GAAS8M,IAAO,yBAAA1E,EAAA1H,OAAA,GAAA2H,EAAA,mB,GAE/C,CAAA1T,IAAA,cAAAC,MAED,SAAYuR,GACU,YAAdA,EAAMzI,KAAqBnJ,KAAK4iB,iBACpCC,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,GAAA1B,EAAA2B,WAAA,oBAAApX,KAAA,KAAkBiG,EACtB,GAAC,CAAAxR,IAAA,gBAAAC,MAED,WACI,GAA2B,MAAvBL,KAAKgjB,eAAT,CACA,IAAMC,EAAOjjB,KAEPkjB,EAAiCljB,KAAKigB,KAAK,kCAAmC,IACpFjgB,KAAKgjB,eAAiBE,EAEtBA,EAAcxR,MAAK,SAASyR,GAgCxB,OA/BA,SAAS1R,IACLwR,EAAKhD,KAAK,uBAAwB,CAAEkD,IAAYzR,MAAK,SAAS0R,GAC1D,GAAIH,EAAKD,gBAAkBE,EAAiB,OAAO,KAEnD,IAAIG,EAAMva,QAAQC,UAYlB,OAXAqa,EAAOnc,SAAQ,SAASrG,GAEpBqiB,EAAK3S,SAAS,KAAO1P,EAAK6D,eAAiB,UAC3C4e,EAAMA,EAAI3R,MAAK,WACX,OAAOuR,EAAKhM,eAAerW,GAAM8Q,MAAK,SAAStG,GAE3C,OADA6X,EAAKjS,KAAK,UAAW5F,GACd,IACX,GACJ,GACJ,IAEOiY,EAAI3R,MAAK,WACZ,OAAO+F,GAAM,IACjB,GACJ,IAAG/F,MAAK,WACJ,GAAIuR,EAAKD,gBAAkBE,EAM3B,OAFAla,YAAW,WAAayI,GAAQ,GAAG,GAE5B,KALHwR,EAAKhD,KAAK,sBAAuB,CAAEkD,GAM3C,IAAGvS,OAAM,SAACrL,GAAmB,GACjC,CACAkM,GAEO0R,CACX,IAAGvS,OAAM,SAACrL,GAAmB,G,CACjC,GAAC,CAAAnF,IAAA,aAAAC,MAED,SAAWuR,GACW,YAAdA,EAAMzI,KAAuD,IAAlCnJ,KAAKsjB,cAAc,aAC9CtjB,KAAKgjB,eAAiB,OAE1BH,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,GAAA1B,EAAA2B,WAAA,mBAAApX,KAAA,KAAiBiG,EACrB,IAUA,EAAAxR,IAAA,aAAAC,MA3QA,WACI,MAAO,uBACX,GAAC,CAAAD,IAAA,qBAAAC,MA0QD,SAA0BW,EAAiCuiB,GAEvD,IAAMC,GAAU5f,EAAAA,EAAAA,IAAYud,IAC5B,GAAIoC,EACA,IAAK,IAAMnjB,KAAOmjB,EACVA,EAAWnjB,KAAQojB,EAAQpjB,IAAO,IAI9CqjB,EAAAA,EAAAA,IAAgBziB,EAAawiB,GAE7B,IAAMze,EAAiD,CAAC,EAmBxD,MAhBA,CAAC,WAAY,WAAY,OAAQ,eAAgB,uBAAwB,QAAS,SAASkC,SAAQ,SAAS7G,GACxG,GAA+B,MAArBY,EAAaZ,GAAvB,CACA,IAAMC,GAAQgF,EAAAA,EAAAA,IAAerE,EAAaZ,IAC9B,aAARA,IAAsBA,EAAM,OAChC2E,EAAO3E,GAAOC,C,CAClB,IAEA,CAAC,OAAQ,KAAM,QAAQ4G,SAAQ,SAAS7G,GACL,MAArBY,EAAaZ,KACvB2E,EAAO3E,IAAOsP,EAAAA,EAAAA,IAAc1O,EAAaZ,IAC7C,IAEUY,EAAaC,aACnB8D,EAAmB,YAAIT,EAAAA,EAAAA,IAAoBtD,EAAaC,aAGrD8D,CACX,KAACqc,CAAA,CA9VwB,CAAQtR,GCjTjC4T,GAAU,KAEd,IAEI,GAAU,OADVA,GAAMC,WACY,MAAM,IAAIjf,MAAM,gB,CACpC,MAAOa,IACL,IAAM7F,GAAS,IAAIC,EAAAA,GAAOF,GAC1BikB,GAAK,WACDhkB,GAAO+M,WAAW,+CAAgD9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACnGC,UAAW,mBAEnB,C,4SCJEjN,GAAS,IAAIC,EAAAA,GAAOF,GAiBtBmkB,GAAS,EAgBAC,GAAkB,SAAAC,IAAA9T,EAAAA,EAAAA,GAAA6T,EAAAC,GAAA,IAAA7T,GAAAC,EAAAA,EAAAA,GAAA2T,GAa3B,SAAAA,EAAY/V,EAAaqC,GAAoB,IAAA4T,EAAAzjB,GAAAT,EAAAA,EAAAA,GAAA,KAAAgkB,GAEzB,QAAZ1T,GACAzQ,GAAO+M,WAAW,uDAAwD9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CAC3GC,UAAW,iBAInBrM,EAAA2P,EAAAtE,KAAA,KAAMmC,EAAKqC,IACNgB,kBAAoB,EAEzB7Q,EAAK0jB,UAAW,GAEhB1a,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,aAAc,IAAIqjB,GAAUrjB,EAAKiiB,WAAWzU,OACjExE,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,YAAa,CAAC,IACnCgJ,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,QAAS,CAAC,IAC/BgJ,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,UAAW,CAAC,IACjCgJ,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,kBAAgBuiB,EAAAA,EAAAA,IAAAkB,GAAAvT,EAAAA,EAAAA,GAAAlQ,IAAAwiB,EAAAA,EAAAA,GAAAe,EAAAd,YAAA,gBAAAgB,GAAApY,KAAAoY,IAGrCzjB,EAAK2jB,WAAWC,OAAS,WACrB5jB,EAAK0jB,UAAW,EAChBhc,OAAOC,KAAK3H,EAAK6jB,WAAWld,SAAQ,SAACib,GACjC5hB,EAAK2jB,WAAWhE,KAAK3f,EAAK6jB,UAAUjC,GAAI3C,QAC5C,GACJ,EAEAjf,EAAK2jB,WAAWG,UAAY,SAACC,GACzB,IAAM1jB,EAAO0jB,EAAa1jB,KACpBoE,EAASgK,KAAKuV,MAAM3jB,GAC1B,GAAiB,MAAboE,EAAOmd,GAAY,CACnB,IAAMA,EAAK1V,OAAOzH,EAAOmd,IACnBD,EAAU3hB,EAAK6jB,UAAUjC,GAG/B,UAFO5hB,EAAK6jB,UAAUjC,QAEAle,IAAlBe,EAAOA,OACPkd,EAAQsC,SAAS,KAAMxf,EAAOA,QAE9BzE,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,WACRH,QAASlT,KAAKuV,MAAMrC,EAAQ1C,SAC5BiD,SAAUzd,EAAOA,OACjB+F,UAAQ0F,EAAAA,EAAAA,GAAAlQ,SAGT,CACH,IAAIiF,EAAe,KACfR,EAAOQ,OACPA,EAAQ,IAAIb,MAAMK,EAAOQ,MAAMwZ,SAAW,kBAC1CzV,EAAAA,EAAAA,IAAoB/D,EAAO,OAAQR,EAAOQ,MAAMyG,MAAQ,OACxD1C,EAAAA,EAAAA,IAAoB/D,EAAO,WAAY5E,IAEvC4E,EAAQ,IAAIb,MAAM,iBAGtBud,EAAQsC,SAAShf,OAAOvB,GAExB1D,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,WACR7c,MAAOA,EACP0c,QAASlT,KAAKuV,MAAMrC,EAAQ1C,SAC5BzU,UAAQ0F,EAAAA,EAAAA,GAAAlQ,I,OAKb,GAAsB,qBAAlByE,EAAOmT,OAA+B,CAE7C,IAAMsM,EAAMlkB,EAAKmkB,MAAM1f,EAAOwT,OAAOmM,cACjCF,GAEAA,EAAIG,YAAY5f,EAAOwT,OAAOxT,O,MAIlCwC,QAAQkB,KAAK,yBAErB,EAKA,IAAMmc,EAAWnQ,aAAY,WACzBnU,EAAK0Q,KAAK,OACd,GAAG,KACsC,OAArC4T,EAASjN,OAASiN,EAASjN,QAAUrX,CAC7C,CAgEC,OAhEAH,EAAAA,EAAAA,GAAA0jB,EAAA,EAAAzjB,IAAA,gBAAAC,MAED,WACI,OAAOL,KAAK6kB,cAChB,GAAC,CAAAzkB,IAAA,kBAAAmJ,IAED,WACI,OAAO,CACX,EAACgL,IAQD,SAAoBlU,GAChBX,GAAO+M,WAAW,mDAAoD9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACvGC,UAAW,sBAEnB,GAAC,CAAAvM,IAAA,mBAAAC,MAVD,SAAiBe,GACb1B,GAAO+M,WAAW,iDAAkD9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACrGC,UAAW,mBAEnB,GAAC,CAAAvM,IAAA,OAAAC,MAQK,W,yJACK,MAAI,wBAAAkL,EAAAY,OAAA,GAAAC,EAAA,I,GACd,CAAAhM,IAAA,UAAAmU,IAED,SAAYlU,GACHA,GAELX,GAAO+M,WAAW,0CAA2C9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CAC9FC,UAAW,cAEnB,GAAC,CAAAvM,IAAA,OAAAC,MAED,SAAK6X,EAAgBK,GAAmB,IAAAhS,EAAA,KAC9Bue,EAAMlB,KAEZ,OAAO,IAAI9a,SAAQ,SAACC,EAASuM,GAMzB,IAAMiK,EAAUxQ,KAAKC,UAAU,CAC3BkJ,OAAQA,EACRK,OAAQA,EACR2J,GAAI4C,EACJ3C,QAAS,QAGb5b,EAAKyK,KAAK,QAAS,CACfoR,OAAQ,UACRH,QAASlT,KAAKuV,MAAM/E,GACpBzU,SAAUvE,IAGdA,EAAK4d,UAAU3X,OAAOsY,IAAQ,CAAEP,SAlBhC,SAAkBhf,EAAcR,GAC5B,OAAIQ,EAAgB+P,EAAO/P,GACpBwD,EAAQhE,EACnB,EAe0Cwa,QAAAA,GAEtChZ,EAAKyd,UAAYzd,EAAK0d,WAAWhE,KAAKV,EAC9C,GACJ,GAAC,CAAAnf,IAAA,aAAAC,MAMK,SAAW8I,EAAa4b,EAAmBJ,G,+IAQ/B,OANM,OADhBK,EAAehlB,KAAKilB,QAAQ9b,MAE5B6b,EAAelc,QAAQ4K,IAAIqR,GAAOrT,MAAK,SAACqT,GACpC,OAAOtS,EAAKwN,KAAK,gBAAiB8E,EACtC,IACA/kB,KAAKilB,QAAQ9b,GAAO6b,GACvB9X,EAAAxB,KAAA,EACmBsZ,EAAY,OAA1BE,EAAKhY,EAAArB,KACX7L,KAAKykB,MAAMS,GAAS,CAAE/b,IAAAA,EAAKwb,YAAAA,GAAc,wBAAAzX,EAAAf,OAAA,GAAAoB,EAAA,S,GAC5C,CAAAnN,IAAA,cAAAC,MAED,SAAYuR,GAAY,IAAA0B,EAAA,KACpB,OAAQ1B,EAAM7Q,MACV,IAAK,QACDf,KAAKmlB,WAAW,QAAS,CAAE,aAAc,SAACpgB,GACtC,IAAM3D,EAAcmD,EAAAA,GAAUhD,KAAKwD,EAAOjE,QAAQ0D,WAClD8O,EAAKhD,SAASnN,MAAQ/B,EACtBkS,EAAKtC,KAAK,QAAS5P,EACvB,IACA,MAEJ,IAAK,UACDpB,KAAKmlB,WAAW,UAAW,CAAE,2BAA4B,SAACpgB,GACtDuO,EAAKtC,KAAK,UAAWjM,EACzB,IACA,MAEJ,IAAK,SACD/E,KAAKmlB,WAAWvT,EAAMzI,IAAK,CAAE,OAAQnJ,KAAKmc,WAAWvK,EAAM9N,UAAW,SAACiB,GAC7C,MAAlBA,EAAOZ,UAAmBY,EAAOZ,SAAU,GAC/CmP,EAAKtC,KAAKY,EAAM9N,OAAQwP,EAAKrI,UAAU/G,UAAUa,GACrD,IACA,MAEJ,IAAK,KACD,IAAMqgB,EAAc,SAACxT,GACjB,IAAMhR,EAAOgR,EAAMhR,KACnB0S,EAAKE,sBAAsB5S,GAAM8Q,MAAK,SAAChP,GAC9BA,GACL4Q,EAAKtC,KAAKpQ,EAAM8B,EACpB,GACJ,EAGA0iB,EAAYxT,GAMZ5R,KAAKmlB,WAAW,KAAM,CAAE,aAAc,SAACpgB,GACnCuO,EAAKjD,QAAQvM,QAAO,SAAC8Z,GAAC,MAAiB,OAAXA,EAAE7c,IAAa,IAAGkG,QAAQme,EAC1D,IACA,MAIJ,IAAK,QACL,IAAK,OACL,IAAK,WACL,IAAK,UACL,IAAK,QACD,MAEJ,QACI7d,QAAQC,IAAI,aAAcoK,GAGtC,GAAC,CAAAxR,IAAA,aAAAC,MAED,SAAWuR,GAAY,IAAAyC,EAAA,KACflL,EAAMyI,EAAMzI,IAEhB,GAAmB,OAAfyI,EAAM7Q,KAAe,CAErB,GAAIf,KAAKqQ,QAAQvM,QAAO,SAAC8Z,GAAC,MAAiB,OAAXA,EAAE7c,IAAa,IAAGiE,OAC9C,OAEJmE,EAAM,I,MACH,GAAInJ,KAAKsjB,cAAc1R,EAAMA,OAEhC,OAGJ,IAAMsT,EAAQllB,KAAKilB,QAAQ9b,GACtB+b,WAECllB,KAAKilB,QAAQ9b,GACpB+b,EAAMxT,MAAK,SAACwT,GACF7Q,EAAKoQ,MAAMS,YACT7Q,EAAKoQ,MAAMS,GAClB7Q,EAAK4L,KAAK,kBAAmB,CAAEiF,IACnC,IACJ,GAAC,CAAA9kB,IAAA,UAAAC,MAEK,W,8IAEEL,KAAKikB,WAAWoB,aAAe1B,GAAU2B,WAAU,CAAA7X,EAAA/B,KAAA,QACnD,OADmD+B,EAAA/B,KAAA,EAC5C,IAAI5C,SAAQ,SAACC,GAChByL,EAAKyP,WAAWC,OAAS,WACrBnb,GAAQ,EACZ,EAEAyL,EAAKyP,WAAWsB,QAAU,WACtBxc,GAAQ,EACZ,CACJ,IAAG,OAKP/I,KAAKikB,WAAWuB,MAAM,KAAM,wBAAA/X,EAAAtB,OAAA,GAAA+C,EAAA,S,IAC/B,EAAA9O,IAAA,aAAAC,MArHD,WACI,MAAO,qBACX,KAACwjB,CAAA,CAnK0B,CAAQzC,I,uSCpCjC1hB,GAAS,IAAIC,EAAAA,GAAOF,GAkBbgmB,GAAsB,SAAA3B,IAAA9T,EAAAA,EAAAA,GAAAyV,EAAA3B,GAAA,IAAA5C,GAAAhR,EAAAA,EAAAA,GAAAuV,GAAA,SAAAA,IAAA,OAAA5lB,EAAAA,EAAAA,GAAA,KAAA4lB,GAAAvE,EAAA3C,MAAA,KAAAL,UAAA,CAmB9B,OAnB8B/d,EAAAA,EAAAA,GAAAslB,EAAA,EAAArlB,IAAA,gBAAAC,MACzB,WAAa,IAAAC,EAAA,K,oPACW,GACX,OADX6P,EAAUnQ,KAAKmQ,SACA,CAAA5E,EAAAG,KAAA,QACL,OADKH,EAAAG,KAAA,EACCuE,EAAMS,cAAa/E,KAAC,MAAC,QAArCwE,EAAO5E,EAAAM,OAGHnM,GAAO+M,WAAW,sBAAuB9M,EAAAA,GAAOsM,OAAOsF,cAAe,CAAC,GAItD,MAAjBvR,KAAKqR,YAEL/H,EAAAA,EAAAA,IAAetJ,KAAM,WAAYmQ,GAEjCnQ,KAAKgR,KAAK,UAAWb,EAAS,OACjC,cAAA5E,EAAAO,OAAA,SAEEqE,GAAO,wBAAA5E,EAAAY,OAAA,GAAAC,EAAA,S,KACjBqZ,CAAA,CAnB8B,CAAQrE,IAsBrBsE,GAAmB,SAAAC,IAAA3V,EAAAA,EAAAA,GAAA0V,EAAAC,GAAA,IAAArE,GAAApR,EAAAA,EAAAA,GAAAwV,GAGrC,SAAAA,EAAYvV,EAAsByV,GAAY,IAAArf,GAAA1G,EAAAA,EAAAA,GAAA,KAAA6lB,GAC1ChmB,GAAOmmB,cAAc,gBAADH,EAAA,KAAA3lB,iBAAA,EAAa2lB,GAGjCvV,GAAUY,EAAAA,EAAAA,IAAS,gBAAA2U,EAAA,KAAA3lB,iBAAA,EAA+C,aAAxDgR,CAAsEZ,GAChFyV,GAAS7U,EAAAA,EAAAA,IAAS,gBAAA2U,EAAA,KAAA3lB,iBAAA,EAAyC,YAAlDgR,CAA+D6U,GAExE,IAAMrD,GAAaxR,EAAAA,EAAAA,IAAS,gBAAA2U,EAAA,KAAA3lB,iBAAA,EAAyB,SAAlCgR,CAA4CZ,EAASyV,GAUvE,OARDrf,EAAA+a,EAAA3V,KAAA,KAAM4W,EAAYpS,GAEK,kBAAZyV,GACPtc,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAjK,GAAO,SAAUqf,GACd,MAAVA,GACP5d,OAAOC,KAAK2d,GAAQ3e,SAAQ,SAAC7G,IACzBkJ,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAjK,GAAiBnG,EAAKwlB,EAAOxlB,GAC/C,IACHmG,CACL,CAkCC,OAlCApG,EAAAA,EAAAA,GAAAulB,EAAA,EAAAtlB,IAAA,gBAAAC,MAED,WACIX,GAAO+I,KAAK,yDAChB,GAAC,CAAArI,IAAA,sBAAAC,MAED,WACI,OAAO,CACX,GAAC,CAAAD,IAAA,YAAAC,MAED,SAAUE,GACN,OAAOb,GAAO+M,WACV,wCACA9M,EAAAA,GAAOsM,OAAOS,sBACd,CAAEC,UAAW,aAErB,GAAC,CAAAvM,IAAA,eAAAC,MAED,WACI,OAAOyI,QAAQC,QAAQ,GAC3B,IAEA,EAAA3I,IAAA,YAAAC,MACA,SAAiBulB,GACb,OAAOA,CACX,GAIA,CAAAxlB,IAAA,SAAAC,MACA,SAAc8P,EAAkByV,GAC5B,OAAOlmB,GAAO+M,WAAW,oDAAqD9M,EAAAA,GAAOsM,OAAO0R,gBAAiB,CACzGhR,UAAW,UAEnB,KAAC+Y,CAAA,CAvDoC,CAAQD,ICtC3C/lB,GAAS,IAAIC,EAAAA,GAAOF,GASpBqmB,GAAgB,mCAETC,GAAyB,SAAAC,IAAAhW,EAAAA,EAAAA,GAAA+V,EAAAC,GAAA,IAAA/V,GAAAC,EAAAA,EAAAA,GAAA6V,GAGlC,SAAAA,EAAY5V,EAAsByV,GAAY,IAAAtlB,GAAAT,EAAAA,EAAAA,GAAA,KAAAkmB,GAC1C,IAAMjb,EAAW,IAAImb,GAAgB9V,EAASyV,GAExC9X,EAAMhD,EAASyX,WAAWzU,IAAI1H,QAAQ,SAAU,MAClBA,QAAQ,eAAgB,mBAGZ,OADhD9F,EAAA2P,EAAAtE,KAAA,KAAMmC,EAAKhD,EAASqF,UACpB7G,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,SAAUwK,EAAS8a,QAAQtlB,CACpD,CAIC,OAJAH,EAAAA,EAAAA,GAAA4lB,EAAA,EAAA3lB,IAAA,sBAAAC,MAED,WACI,OAAQL,KAAK4lB,SAAWE,EAC5B,KAACC,CAAA,CAfiC,CAAQlC,IAkBjCoC,GAAgB,SAAAC,IAAAlW,EAAAA,EAAAA,GAAAiW,EAAAC,GAAA,IAAAhF,GAAAhR,EAAAA,EAAAA,GAAA+V,GAAA,SAAAA,IAAA,OAAApmB,EAAAA,EAAAA,GAAA,KAAAomB,GAAA/E,EAAA3C,MAAA,KAAAL,UAAA,CAoDxB,OApDwB/d,EAAAA,EAAAA,GAAA8lB,EAAA,EAAA7lB,IAAA,sBAAAC,MAsDzB,WACI,OAAQL,KAAK4lB,SAAWE,EAC5B,IAAC,EAAA1lB,IAAA,uBAAAC,MAtDD,SAA4B8P,EAAsByV,GAC9C,OAAO,IAAIG,GAAyB5V,EAASyV,EACjD,GAAC,CAAAxlB,IAAA,YAAAC,MAED,SAAiBulB,GACb,OAAc,MAAVA,EAAyBE,IACzBF,GAA6B,kBAAZA,GACjBlmB,GAAOoF,mBAAmB,iBAAkB,SAAU8gB,GAEnDA,EACX,GAAC,CAAAxlB,IAAA,SAAAC,MAED,SAAc8P,EAAkByV,GAC5B,IAAIO,EAAO,KACX,OAAQhW,EAAQpF,MACZ,IAAK,YACDob,EAAO,gCACP,MACJ,IAAK,UACDA,EAAO,gCACP,MACJ,IAAK,UACDA,EAAO,gCACP,MACJ,IAAK,SACDA,EAAO,+BACP,MACJ,IAAK,QACDA,EAAO,8BACP,MACJ,IAAK,QACDA,EAAO,oCACP,MACJ,IAAK,WACDA,EAAO,mCACP,MACJ,QACGzmB,GAAOoF,mBAAmB,sBAAuB,UAAWoZ,UAAU,IAG7E,MAAO,CACHkI,WAAW,EACXtY,IAAM,WAAkBqY,EAAOP,EAC/BS,iBAAkB,SAACC,EAAiBxY,GAIhC,OAHI8X,IAAWE,IACXxe,IAEGwB,QAAQC,SAAQ,EAC3B,EAER,KAACkd,CAAA,CApDwB,CAAQP,I,uSCjC/BhmB,GAAS,IAAIC,EAAAA,GAAOF,GAEb8mB,GAAmB,SAAAL,IAAAlW,EAAAA,EAAAA,GAAAuW,EAAAL,GAAA,IAAAhF,GAAAhR,EAAAA,EAAAA,GAAAqW,GAAA,SAAAA,IAAA,OAAA1mB,EAAAA,EAAAA,GAAA,KAAA0mB,GAAArF,EAAA3C,MAAA,KAAAL,UAAA,CAoB3B,OApB2B/d,EAAAA,EAAAA,GAAAomB,EAAA,EAAAnmB,IAAA,UAAAC,MAsBtB,SAAQ6X,EAAgBK,GAAW,IAAAjY,EAAA,K,2OAGtB,mBAAX4X,EAA2B,CAAA3M,EAAAG,KAAA,QACb,OADaH,EAAAG,KAAA,EACPuE,EAAMoC,QAAO1G,KAAC,gBAAY,CAAEjL,SAAU,WAAW,OAA1D,OAALyC,EAAKoI,EAAAM,KAAAN,EAAAO,OAAA,SACJ3I,EAAMrC,QAAM,cAAAyK,EAAAO,OAAA,SAGhBmE,EAAMoC,QAAO1G,KAAC,KAAAuM,EAAQK,IAAM,wBAAAhN,EAAAY,OAAA,GAAAC,EAAA,S,IACtC,EAAAhM,IAAA,YAAAC,MA7BD,SAAiBulB,GAIb,OAHc,MAAVA,GACAlmB,GAAOoF,mBAAmB,sCAAuC,SAAU8gB,GAExE,IACX,GAAC,CAAAxlB,IAAA,SAAAC,MAED,SAAc8P,EAAkByV,GAC5B,IAAIO,EAAO,KACX,GACS,cADDhW,EAAQpF,KAERob,EAAO,mCAGRzmB,GAAOoF,mBAAmB,sBAAuB,UAAWoZ,UAAU,IAG7E,OAAOiI,CACX,KAACI,CAAA,CApB2B,CAAQb,I,uSCIlChmB,GAAS,IAAIC,EAAAA,GAAOF,GAM1B,SAAS+mB,GAAuBxlB,GAC5B,IAAM+D,EAAiC,CAAC,EACxC,IAAK,IAAI3E,KAAOY,EACZ,GAA+B,MAArBA,EAAaZ,GAAvB,CACA,IAAIC,EAAcW,EAAaZ,GACnB,SAARA,GAA4B,IAAVC,IAMlBA,EAHM,CAAEU,MAAM,EAAMY,UAAU,EAAMH,UAAU,EAAMilB,aAAa,EAAMhlB,sBAAsB,EAAMI,OAAO,EAAMxB,OAAO,GAAQD,IACvHiF,EAAAA,EAAAA,KAASqK,EAAAA,EAAAA,IAAQrP,IACV,eAARD,EACC,KAAMkE,EAAAA,EAAAA,IAAcjE,GAAOqG,KAAI,SAAC6N,GACpC,MAAO,aAAPlK,OAAqBkK,EAAIhU,QAAQ,oBAAA8J,OAAoBkK,EAAImS,YAAYve,KAAK,OAAO,MACrF,IAAGA,KAAK,KAAO,KAEPuH,EAAAA,EAAAA,IAAQrP,GAEpB0E,EAAO3E,GAAOC,E,CAElB,OAAO0E,CACX,CAEA,SAASua,GAAUva,GAEf,GAAqB,GAAjBA,EAAO7B,SAAmC,qBAAnB6B,EAAOga,SAAqD,0BAAnBha,EAAOga,SACvE,OAAOha,EAAOA,OAGlB,GAAqB,GAAjBA,EAAO7B,QAAiC,MAAlB6B,EAAOga,QAAiB,CAC9C,IAAMxZ,EAAa,IAAIb,MAAM,oBAK7B,MAJAa,EAAMR,OAASgK,KAAKC,UAAUjK,IACzBA,EAAOA,QAAU,IAAIN,cAAc6D,QAAQ,eAAiB,IAC7D/C,EAAMohB,eAAgB,GAEpBphB,C,CAGV,OAAOR,EAAOA,MAClB,CAEA,SAAS6hB,GAAc7hB,GAEnB,GAAIA,GAAkC,GAAlBA,EAAQ7B,QAAwC,SAAnB6B,EAAQga,UAAuBha,EAAOA,QAAU,IAAIN,cAAc6D,QAAQ,eAAiB,EAAG,CAC3I,IAAM/C,EAAa,IAAIb,MAAM,sBAG7B,MAFAa,EAAMR,OAASgK,KAAKC,UAAUjK,GAC9BQ,EAAMohB,eAAgB,EAChBphB,C,CAGV,GAAsB,OAAlBR,EAAOod,QAAkB,CAEzB,IAAM5c,EAAa,IAAIb,MAAM,oBAE7B,MADAa,EAAMR,OAASgK,KAAKC,UAAUjK,GACxBQ,C,CAGV,GAAIR,EAAOQ,MAAO,CAEd,IAAMA,EAAa,IAAIb,MAAMK,EAAOQ,MAAMwZ,SAAW,iBAGrD,MAFIha,EAAOQ,MAAMyG,OAAQzG,EAAMyG,KAAOjH,EAAOQ,MAAMyG,MAC/CjH,EAAOQ,MAAM5E,OAAQ4E,EAAM5E,KAAOoE,EAAOQ,MAAM5E,MAC7C4E,C,CAGV,OAAOR,EAAOA,MAClB,CAGA,SAAS8hB,GAAYnmB,GACjB,GAAiB,YAAbA,EAA0B,MAAM,IAAIgE,MAAM,yBAC9C,MAAiB,WAAbhE,EAAgCA,EAE7ByF,SAASzF,EAASkE,UAAU,GAAI,GAC3C,CAGA,IAAMkhB,GAAgB,qCAEtB,SAAShH,GAAW5G,EAAgB3S,EAAYvE,GAG5C,GAAe,SAAXkX,GAAqB3S,EAAMyG,OAASrM,EAAAA,GAAOsM,OAAOgM,aAAc,CAChE,IAAM2F,EAAIrY,EAAMA,MAGhB,GAAIqY,IAAMA,EAAEmB,QAAQjS,MAAM,cAAgB8Q,EAAEmB,QAAQjS,MAAM,wBAAyB,CAE/E,IAAInM,EAAOid,EAAEjd,KAGb,GAFIA,IAAQA,EAAO,KAAOA,EAAKyF,QAAQ,SAAU,MAE7CvB,EAAAA,EAAAA,IAAYlE,GAAS,OAAOA,EAEhCjB,GAAO+M,WAAW,wCAAyC9M,EAAAA,GAAOsM,OAAOC,eAAgB,CACrF3G,MAAAA,EAAO5E,KAAM,M,EAMzB,IAAIoe,EAAUxZ,EAAMwZ,QAuCpB,MAtCIxZ,EAAMyG,OAASrM,EAAAA,GAAOsM,OAAOgM,eACzB1S,EAAMA,OAAyC,kBAAzBA,EAAMA,MAAMwZ,QAClCA,EAAUxZ,EAAMA,MAAMwZ,QACQ,kBAAhBxZ,EAAMyZ,KACpBD,EAAUxZ,EAAMyZ,KACsB,kBAAxBzZ,EAAM0Z,eACpBF,EAAUxZ,EAAM0Z,gBAGxBF,GAAWA,GAAW,IAAIta,eAGdqI,MAAM,uBACdpN,GAAO+M,WAAW,oDAAqD9M,EAAAA,GAAOsM,OAAOiT,mBAAoB,CACtG3Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAKlB+d,EAAQjS,MAAM,8EACdpN,GAAO+M,WAAW,8BAA+B9M,EAAAA,GAAOsM,OAAOkT,cAAe,CAC3E5Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAKlB+d,EAAQjS,MAAM,wCACbpN,GAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOmT,wBAAyB,CACjF7Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAInB+d,EAAQjS,MAAM,4DACdpN,GAAO+M,WAAW,4EAA6E9M,EAAAA,GAAOsM,OAAOoT,wBAAyB,CAClI9Z,MAAAA,EAAO2S,OAAAA,EAAQlX,YAAAA,IAIjBuE,CACV,CAEO,IAAMuhB,GAAkB,SAAAzF,IAAArR,EAAAA,EAAAA,GAAA8W,EAAAzF,GAAA,IAAAH,GAAAhR,EAAAA,EAAAA,GAAA4W,GAI3B,SAAAA,EAAY3W,EAAsByV,GAAe,IAAAtlB,EAMW,OANXT,EAAAA,EAAAA,GAAA,KAAAinB,GAC7CpnB,GAAOI,SAAS,gBAADgnB,EAAA,KAAA/mB,iBAAA,EAAa+mB,GAE5BxmB,EAAA4gB,EAAAvV,KAAA,KAAMwE,IAEN7G,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,UAAWA,EAAKymB,eACrCzd,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,SAAUslB,GAAUE,IAAexlB,CAC5D,CAqRC,OArRAH,EAAAA,EAAAA,GAAA2mB,EAAA,EAAA1mB,IAAA,aAAAC,MAED,WACI,OAAOL,KAAKmQ,QAAUnQ,KAAKmQ,QAAQpF,KAAM,WACrC,IAAK,YACD,MAAO,2BACX,IAAK,UACD,MAAO,mCACX,IAAK,UACD,MAAO,mCACX,IAAK,QACD,MAAO,iCACX,IAAK,SACD,MAAO,kCAIf,OAAOrL,GAAOoF,mBAAmB,sBAAuB,UAAWiG,KACvE,GAAC,CAAA3K,IAAA,SAAAC,MAED,SAAO2mB,EAAgBzO,GACnB,IAAM0O,EAAQjf,OAAOC,KAAKsQ,GAAQ2O,QAAO,SAACC,EAAO/mB,GAC7C,IAAMC,EAAQkY,EAAOnY,GAIrB,OAHa,MAATC,IACA8mB,GAAS,IAAJ9c,OAASjK,EAAI,KAAAiK,OAAKhK,IAEpB8mB,CACX,GAAG,IACGvB,EAAW5lB,KAAK4lB,OAAM,WAAAvb,OAAgBrK,KAAK4lB,QAAW,GAC5D,MAAO,GAAPvb,OAAWrK,KAAKonB,QAAQ,gBAAA/c,OAAgB2c,GAAO3c,OAAI4c,GAAM5c,OAAIub,EACjE,GAAC,CAAAxlB,IAAA,aAAAC,MAED,WACI,MAAO,GAAPgK,OAAWrK,KAAKonB,QAAQ,OAC5B,GAAC,CAAAhnB,IAAA,cAAAC,MAED,SAAY2mB,EAAgBzO,GAGxB,OAFAA,EAAOyO,OAASA,EAChBzO,EAAO8O,OAASrnB,KAAK4lB,OACdrN,CACX,GAAC,CAAAnY,IAAA,QAAAC,MAEK,SAAM2mB,EAAgBzO,EAA6B+O,G,uJA8BtC,OA7BTxZ,EAAOwZ,EAAOtnB,KAAKunB,aAAcvnB,KAAKwnB,OAAOR,EAAQzO,GACrDgH,EAAW+H,EAAOtnB,KAAKynB,YAAYT,EAAQzO,GAAS,KACpDmP,EAAuB,UAAXV,EAAsBJ,GAAetH,GAEvDtf,KAAKgR,KAAK,QAAS,CACfoR,OAAQ,UACRH,QAASnU,EACThD,SAAU9K,OAGRuiB,EAA6B,CAC/BzU,IAAKA,EACL6Z,qBAAsB,IACtBtB,iBAAkB,SAACC,EAAiBxY,GAIhC,OAHIvH,EAAKa,uBACLE,IAEGwB,QAAQC,SAAQ,EAC3B,GAGA6e,EAAqB,KACrBrI,IACAgD,EAAWsF,QAAU,CAAE,eAAgB,oDACvCD,EAAa5f,OAAOC,KAAKsX,GAAS7Y,KAAI,SAACtG,GACnC,MAAO,GAAPiK,OAAWjK,EAAI,KAAAiK,OAAKkV,EAAQnf,GAChC,IAAG+H,KAAK,MACXoD,EAAAG,KAAA,GAEoBkD,EAAAA,EAAAA,IAAU2T,EAAYqF,EAAYF,GAAYd,IAAc,OAO9E,OAPG7hB,EAAMwG,EAAAM,KAEZ7L,KAAKgR,KAAK,QAAS,CACfoR,OAAQ,WACRH,QAASnU,EACT0U,UAAUH,EAAAA,EAAAA,IAAStd,GACnB+F,SAAU9K,OACXuL,EAAAO,OAAA,SAEI/G,GAAM,yBAAAwG,EAAAY,OAAA,GAAAC,EAAA,S,GAChB,CAAAhM,IAAA,gBAAAC,MAEK,W,yJACKL,KAAKmQ,SAAO,wBAAAjD,EAAAf,OAAA,GAAAoB,EAAA,S,GACtB,CAAAnN,IAAA,UAAAC,MAEK,SAAQ6X,EAAgBK,GAAW,IAAA9F,EAAA,K,6PAE7ByF,EAAMzK,EAAA/B,KACL,mBADK+B,EAAAhC,GACW,EAGhB,gBAHgBgC,EAAAhC,GAGH,EAGb,eAHagC,EAAAhC,GAGD,EAQZ,wBARYgC,EAAAhC,GAQS,EAOrB,YAPqBgC,EAAAhC,GAOZ,EAOT,iBAPSgC,EAAAhC,GAOK,EAQd,oBARcgC,EAAAhC,GAQG,EAQjB,aARiBgC,EAAAhC,GAQP,GAUV,mBAVUgC,EAAAhC,GAUM,GAMhB,0BANgBgC,EAAAhC,GAMO,GAMvB,SANuBgC,EAAAhC,GAMjB,GAgBN,gBAhBMgC,EAAAhC,GAgBO,GAYb,YAZagC,EAAAhC,GAYJ,GAmDT,kBAnDSgC,EAAAhC,GAmDM,0BAAAgC,EAAA3B,OAAA,SAhJT9L,KAAK8nB,MAAM,QAAS,CAAE1F,OAAQ,qBAAoB,cAAA3U,EAAA3B,OAAA,SAGlD9L,KAAK8nB,MAAM,QAAS,CAAE1F,OAAQ,kBAAiB,cAAA3U,EAAA3B,OAAA,SAI/C9L,KAAK8nB,MAAM,UAAW,CACzB1F,OAAQ,UACR7hB,QAASgY,EAAOhY,QAChB4I,IAAKoP,EAAO7X,YACd,cAAA+M,EAAA3B,OAAA,SAGK9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,0BACR7hB,QAASgY,EAAOhY,QAChB4I,IAAKoP,EAAO7X,YACd,cAAA+M,EAAA3B,OAAA,SAGK9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,cACR7hB,QAASgY,EAAOhY,QAChB4I,IAAKoP,EAAO7X,YACd,cAAA+M,EAAA3B,OAAA,SAGK9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,mBACR7hB,QAASgY,EAAOhY,QAChBsY,SAAUN,EAAOM,SACjB1P,IAAKoP,EAAO7X,YACd,cAAA+M,EAAA3B,OAAA,SAGK9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,yBACRvhB,IAAK0X,EAAOiB,oBACb,GAAM5I,OAAM,SAACrL,GACZ,OAAOuZ,GAAW,kBAAmBvZ,EAAOgT,EAAOiB,kBACvD,KAAE,YAGEjB,EAAO7X,SAAU,CAAF+M,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SACR9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,uBACRjZ,IAAKoP,EAAO7X,SACZ0D,QAAUmU,EAAOsC,oBAAsB,OAAQ,WACjD,cAEA,IAAInW,MAAM,yCAAwC,eAAA+I,EAAA3B,OAAA,SAGjD9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,2BACR2F,OAAQxP,EAAOjW,mBACjB,eAAAmL,EAAA3B,OAAA,SAGK9L,KAAK8nB,MAAM,QAAS,CACvB1F,OAAQ,4BACR2F,OAAQxP,EAAOjW,mBACjB,WAGsB,WAApBiW,EAAO7X,SAAqB,CAAA+M,EAAA/B,KAAA,eACtB,IAAIhH,MAAM,wDAAuD,QAQhE,OALLsjB,EAAWxB,GAAuBjO,EAAOvX,cACtCgmB,OAAS,QAClBgB,EAAS5F,OAAS,WAAW3U,EAAAjC,KAAA,GAAAiC,EAAA/B,KAAA,GAGZ1L,KAAK8nB,MAAM,QAASE,GAAU,GAAK,eAAAva,EAAA3B,OAAA,SAAA2B,EAAA5B,MAAA,eAAA4B,EAAAjC,KAAA,GAAAiC,EAAA7B,GAAA6B,EAAA,UAAAA,EAAA3B,OAAA,SAEzCgT,GAAW,OAAMrR,EAAA7B,GAAS2M,EAAOvX,cAAY,QAU7C,OALLgnB,EAAWxB,GAAuBjO,EAAOvX,cACtCgmB,OAAS,QAClBgB,EAAS5F,OAAS,kBAAkB3U,EAAAjC,KAAA,GAAAiC,EAAA/B,KAAA,GAGnB1L,KAAK8nB,MAAM,QAASE,GAAU,GAAK,eAAAva,EAAA3B,OAAA,SAAA2B,EAAA5B,MAAA,eAAA4B,EAAAjC,KAAA,GAAAiC,EAAA1B,GAAA0B,EAAA,UAAAA,EAAA3B,OAAA,SAEzCgT,GAAW,cAAarR,EAAA1B,GAASwM,EAAOvX,cAAY,QAkCtC,OA7BnBmd,EAA4B,CAAEiE,OAAQ,WAExC7J,EAAOzU,OAAOC,YACdoa,EAAKpa,UAAY8iB,GAAYtO,EAAOzU,OAAOC,YAG3CwU,EAAOzU,OAAOG,UACdka,EAAKla,QAAU4iB,GAAYtO,EAAOzU,OAAOG,UAGzCsU,EAAOzU,OAAOvD,UACd4d,EAAK5d,QAAUgY,EAAOzU,OAAOvD,SAI7BgY,EAAOzU,OAAOvB,QAAUgW,EAAOzU,OAAOvB,OAAOyC,OAAS,IAClDuT,EAAOzU,OAAOvB,OAAOyC,OAAS,GAC9BtF,GAAO+M,WAAW,0BAA2B9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CAAEnK,OAAQgW,EAAOzU,OAAOvB,SAG1E,IAAhCgW,EAAOzU,OAAOvB,OAAOyC,SAEE,kBADjBijB,EAAS1P,EAAOzU,OAAOvB,OAAO,KACiB,KAAlB0lB,EAAOjjB,QACtCtF,GAAO+M,WAAW,2BAA4B9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CAAEub,OAAQA,IAEjG9J,EAAK8J,OAASA,IAErBxa,EAAA/B,KAAA,GAE8B1L,KAAK8nB,MAAM,OAAQ3J,GAAK,QAAjDpb,EAAI0K,EAAA5B,KAGNqc,EAAoC,CAAC,EAGhCta,EAAI,EAAC,aAAEA,EAAI7K,EAAKiC,QAAM,CAAAyI,EAAA/B,KAAA,SACR,GACE,OADflE,EAAMzE,EAAK6K,IACTzM,UAAiB,CAAAsM,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,0BACM,MAA3Boc,EAAO1gB,EAAIpG,aAAoB,CAAAqM,EAAA/B,KAAA,SACjB,OADiB+B,EAAA/B,KAAA,GACX1L,KAAKmoB,SAAS3gB,EAAIpG,aAAY,SAA5C+B,EAAKsK,EAAA5B,QAEPqc,EAAO1gB,EAAIpG,aAAe+B,EAAMvC,MACnC,QAEL4G,EAAIrG,UAAY+mB,EAAO1gB,EAAIpG,aAAa,QATXwM,IAAGH,EAAA/B,KAAA,wBAAA+B,EAAA3B,OAAA,SAY7B/I,GAAI,WAIe,cAAtB/C,KAAKmQ,QAAQpF,KAAoB,CAAA0C,EAAA/B,KAAA,gBAAA+B,EAAA3B,OAAA,SAAW,GAAG,QAChC,OADgC2B,EAAAU,GAC5Cia,WAAU3a,EAAA/B,KAAA,GAAQ1L,KAAK8nB,MAAM,QAAS,CAAE1F,OAAQ,aAAa,QAAQ,OAAR3U,EAAAY,GAAAZ,EAAA5B,KAAEwc,OAAM5a,EAAA3B,OAAA,YAAA2B,EAAAU,IAAAV,EAAAY,KAAA,eAAAZ,EAAA3B,OAAA,2BAAA2B,EAAA3B,OAAA,SAM7EmE,EAAMoC,QAAO1G,KAAC,KAAAuM,EAAQK,IAAM,yBAAA9K,EAAAtB,OAAA,GAAA+C,EAAA,2B,GAMvC,CAAA9O,IAAA,aAAAC,MACM,SAAW+X,EAAyCpC,EAAuBsS,G,+IAG/D,O,SAAMtoB,KAAK0a,YAAYtC,GAAc,OAMpC,OANoCjJ,EAAA1D,GAAA0D,EAAAtD,KAAAsD,EAAAvD,GACnB,MAAdoK,EAAsB,EAAGA,EAAU7G,EAAApD,GACzB,MAAZuc,EAAoB,SAAUA,EAJxC/P,EAAS,CACX6J,OAAQ,SACR7hB,QAAO4O,EAAA1D,GACP8c,WAAUpZ,EAAAvD,GACV4c,SAAQrZ,EAAApD,GACR7D,KAAM,OAAKiH,EAAAzD,KAAA,EAGM1L,KAAK8nB,MAAM,UAAWvP,GAAO,OAAtC,OAANxT,EAAMoK,EAAAtD,KAAAsD,EAAArD,OAAA,SAEL/G,EAAO2B,KAAI,SAAC0E,GACf,CAAC,kBAAmB,MAAMnE,SAAQ,SAAS7G,GACxB,IAAXgL,EAAGhL,WAAqBgL,EAAGhL,EACnC,IACkB,MAAdgL,EAAGlJ,SAAyC,MAAtBkJ,EAAGzI,kBACzByI,EAAGlJ,QAAUkJ,EAAGzI,iBAEpB,IAAM8lB,EAAOnV,EAAKrI,UAAUpH,oBAAoBuH,GAEhD,OADIA,EAAGsd,YAAaD,EAAKplB,UAAY8C,SAASiF,EAAGsd,YAC1CD,CACX,KAAE,yBAAAtZ,EAAAhD,OAAA,GAAAmD,EAAA,S,GACL,CAAAlP,IAAA,sBAAAC,MAED,WACI,OAAQL,KAAK4lB,SAAWE,EAC5B,KAACgB,CAAA,CAhS0B,CAAQhX,GC9JjC,SAAU6Y,GAAS3hB,GAGrB,IAAK,IAAI4G,GAFT5G,EAAQA,EAAMY,SAEK5C,OAAS,EAAG4I,EAAI,EAAGA,IAAK,CACvC,IAAMgb,EAAI3V,KAAK4V,MAAM5V,KAAK6V,UAAYlb,EAAI,IACpCmb,EAAM/hB,EAAM4G,GAClB5G,EAAM4G,GAAK5G,EAAM4hB,GACjB5hB,EAAM4hB,GAAKG,C,CAGf,OAAO/hB,CACX,C,2SCEMtH,GAAS,IAAIC,EAAAA,GAAOF,GAE1B,SAASqV,KAAQ,OAAQ,IAAInM,MAAQD,SAAW,CAIhD,SAASsgB,GAAcC,GAGnB,IAFA,IAAIlkB,EAAS,KAEJ6I,EAAI,EAAGA,EAAIqb,EAASjkB,OAAQ4I,IAAK,CACtC,IAAMuC,EAAU8Y,EAASrb,GAGzB,GAAe,MAAXuC,EAAmB,OAAO,KAE1BpL,EAEMA,EAAOgG,OAASoF,EAAQpF,MAAQhG,EAAOkB,UAAYkK,EAAQlK,UAC3DlB,EAAO8X,aAAe1M,EAAQ0M,YAAqC,MAArB9X,EAAO8X,YAA4C,MAAtB1M,EAAQ0M,aAErFnd,GAAOoF,mBAAmB,oBAAqB,WAAYmkB,GAG/DlkB,EAASoL,C,CAIjB,OAAOpL,CACX,CAEA,SAASmkB,GAAOrP,EAAuBsP,GACnCtP,EAASA,EAAOjS,QAAQM,OACxB,IAAMkhB,EAASnW,KAAK4V,MAAMhP,EAAO7U,OAAS,GAG1C,GAAI6U,EAAO7U,OAAS,EAChB,OAAO6U,EAAOuP,GAIlB,IAAMpH,EAAInI,EAAOuP,EAAS,GAAIC,EAAIxP,EAAOuP,GAEzC,OAAgB,MAAZD,GAAoBlW,KAAKC,IAAI8O,EAAIqH,GAAKF,EAC/B,MAGHnH,EAAIqH,GAAK,CACrB,CAEA,SAASC,GAAUjpB,GACf,GAAc,OAAVA,EACA,MAAO,OACJ,GAAsB,kBAAXA,GAAyC,mBAAXA,EAC5C,OAAO0O,KAAKC,UAAU3O,GACnB,GAAsB,kBAAXA,EACd,OAAOA,EACJ,GAAIkE,EAAAA,GAAUglB,YAAYlpB,GAC7B,OAAOA,EAAMmO,WACV,GAAIhI,MAAMC,QAAQpG,GACrB,OAAO0O,KAAKC,UAAU3O,EAAMqG,KAAI,SAACkH,GAAC,OAAK0b,GAAU1b,EAAE,KAChD,GAAsB,kBAAXvN,EAAqB,CACnC,IAAM4H,EAAOD,OAAOC,KAAK5H,GAEzB,OADA4H,EAAKC,OACE,IAAMD,EAAKvB,KAAI,SAACtG,GACnB,IAAI6B,EAAI5B,EAAMD,GAMd,OAJI6B,EADc,oBAAPA,EACH,aAEAqnB,GAAUrnB,GAEX8M,KAAKC,UAAU5O,GAAO,IAAM6B,CACvC,IAAGkG,KAAK,KAAO,G,CAGnB,MAAM,IAAIzD,MAAM,8BAAgCrE,EACpD,CAGA,IAAImpB,GAAU,EA+Bd,SAAS5gB,GAAMC,GACX,IAAI4gB,EAAqB,KAErBhS,EAAsB,KACtBiS,EAA0B,IAAI5gB,SAAQ,SAACC,GACvC0gB,EAAS,WACDhS,IACAG,aAAaH,GACbA,EAAQ,MAEZ1O,GACJ,EACA0O,EAAQzO,WAAWygB,EAAQ5gB,EAC/B,IAWA,MAAO,CAAE4gB,OAAAA,EAAQE,WAJjB,WACI,OAAOD,CACX,EAE6BtQ,KAThB,SAAC1D,GAEV,OADAgU,EAAUA,EAAQhY,KAAKgE,EAE3B,EAOJ,CAEA,IAAMkU,GAAgB,CAClBjqB,EAAAA,GAAOsM,OAAOC,eACdvM,EAAAA,GAAOsM,OAAOiT,mBACdvf,EAAAA,GAAOsM,OAAOkT,cACdxf,EAAAA,GAAOsM,OAAOmT,wBACdzf,EAAAA,GAAOsM,OAAOoT,yBAGZwK,GAAoB,CACtB,UACA,OACA,YACA,iBACA,SACA,eAeJ,SAASC,GAAkBC,EAAuBjV,GAC9C,IAAM/P,EAAc,CAChBilB,OAAQD,EAAOC,QAYnB,OAVAhiB,OAAOiiB,eAAellB,EAAQ,WAAY,CAAEwE,IAAK,kBAAMwgB,EAAOjf,QAAQ,IAClEif,EAAOG,QAASnlB,EAAOmlB,MAAQH,EAAOG,OACtCpV,IAAO/P,EAAO8D,SAAYiM,EAAMiV,EAAOG,OACvCH,EAAOvU,OACHuU,EAAOxkB,MACPR,EAAOQ,MAAQwkB,EAAOxkB,MAEtBR,EAAOA,OAASglB,EAAOhlB,QAAU,MAGlCA,CACX,CA0BA,SAASolB,GAAerf,EAA4BoN,EAAgBK,GAEhE,IAAI6R,EAAYd,GAEhB,OAAQpR,GACJ,IAAK,iBAKD,OAAO,SAASmS,GACZ,IAAMxQ,EAASwQ,EAAQ3jB,KAAI,SAAC4jB,GAAC,OAAKA,EAAEvlB,MAAM,IAGtC3D,EAAc8nB,GAAOmB,EAAQ3jB,KAAI,SAAC4jB,GAAC,OAAKA,EAAEvlB,MAAM,IAAG,GACvD,GAAmB,MAAf3D,EAYJ,OAVAA,EAAc6R,KAAKsX,KAAKnpB,GAGpByY,EAAOvR,QAAQlH,EAAc,IAAM,GAAKA,IAGxCA,GAAe0J,EAAS0f,sBACxB1f,EAAS0f,oBAAsBppB,GAG5B0J,EAAS0f,mBACpB,EAEJ,IAAK,cAID,OAAO,SAASH,GACZ,IAAMxQ,EAASwQ,EAAQ3jB,KAAI,SAAC4jB,GAAC,OAAKA,EAAEvlB,MAAM,IAE1C,OADA8U,EAAO3R,OACA2R,EAAO5G,KAAK4V,MAAMhP,EAAO7U,OAAS,GAC7C,EAEJ,IAAK,gBAGD,OAAO,SAASqlB,GACZ,OAAOnB,GAAOmB,EAAQ3jB,KAAI,SAAC4jB,GAAC,OAAKA,EAAEvlB,MAAM,IAC7C,EAGJ,IAAK,aACL,IAAK,sBACL,IAAK,UACL,IAAK,eACL,IAAK,OACL,IAAK,cACL,IAAK,UACD,MAGJ,IAAK,iBACL,IAAK,wBACDqlB,EAAY,SAAShf,GACjB,OAAU,MAANA,EAAqB,OAEzBA,GAAKxH,EAAAA,EAAAA,IAAYwH,IACd9J,eAAiB,EACbgoB,GAAUle,GACrB,EACA,MAGJ,IAAK,WAGGgf,EADA7R,EAAOsC,oBACK,SAAS1X,GACjB,OAAa,MAATA,EAAwB,OAE5BA,GAAQS,EAAAA,EAAAA,IAAYT,IACdM,aAAeN,EAAMM,aAAaiD,KAAI,SAAC0E,GAGzC,OAFAA,GAAKxH,EAAAA,EAAAA,IAAYwH,IACd9J,eAAiB,EACb8J,CACX,IACOke,GAAUnmB,GACrB,EAEY,SAASA,GACjB,OAAa,MAATA,EAAwB,KACrBmmB,GAAUnmB,EACrB,EAEJ,MAEJ,QACI,MAAM,IAAIuB,MAAM,mBAAqBwT,GAK7C,OA1HJ,SAAyBkS,EAAmCK,GACxD,OAAO,SAASJ,GAGZ,IAAMK,EAA4D,CAAC,EACnEL,EAAQpjB,SAAQ,SAACqjB,GACb,IAAMjqB,EAAQ+pB,EAAUE,EAAEvlB,QACrB2lB,EAAMrqB,KAAUqqB,EAAMrqB,GAAS,CAAEsqB,MAAO,EAAG5lB,OAAQulB,EAAEvlB,SAC1D2lB,EAAMrqB,GAAOsqB,OACjB,IAIA,IADA,IAAM1iB,EAAOD,OAAOC,KAAKyiB,GAChB9c,EAAI,EAAGA,EAAI3F,EAAKjD,OAAQ4I,IAAK,CAClC,IAAMhI,EAAQ8kB,EAAMziB,EAAK2F,IACzB,GAAIhI,EAAM+kB,OAASF,EACf,OAAO7kB,EAAMb,M,CAMzB,CACJ,CAmGW6lB,CAAgBR,EAAWtf,EAAS2f,OAE/C,CAIA,SAAeI,GAAYd,EAAuB3oB,G,sIACC,KAElB,OAFvB0J,EAA0Bif,EAAOjf,UAEzB1J,aAAuB0J,EAAS1J,aAAeA,IAAiC,IAAjBA,GAAkB,CAAAmK,EAAAG,KAAA,eAAAH,EAAAO,OAAA,SACpFhB,GAAQ,cAAAS,EAAAO,OAAA,UAGZ2F,EAAAA,EAAAA,KAAK,WACR,OAAO,IAAI3I,SAAQ,SAACC,EAASuM,GACzBtM,YAAW,WAGP,OAAI8B,EAAS1J,aAAeA,EAAsB2H,EAAQ+B,GAGtDif,EAAOzS,UAAoBvO,EAAQ,MAGhCA,OAAQ/E,EACnB,GAAG,EACP,GACJ,GAAG,CAAEqX,SAAUvQ,KAAW,wBAAAS,EAAAY,OAAA,GAAAC,EAAA,I,CAG9B,SAAe0e,GAAUf,EAAuBgB,EAA4B7S,EAAgBK,G,wIACpFzN,EAAWif,EAAOjf,SAAQoC,EAAAzB,GAEtByM,EAAMhL,EAAAxB,KACL,mBADKwB,EAAAzB,IAEL,gBADgByB,EAAAzB,GAAA,EAGhB,kBAFayB,EAAAzB,GAEE,EAKf,eALeyB,EAAAzB,IAMf,wBADYyB,EAAAzB,IAEZ,YADqByB,EAAAzB,GADT,EAOZ,iBALSyB,EAAAzB,GAKK,GAKd,aALcyB,EAAAzB,GAKJ,GAKV,SALUyB,EAAAzB,IAMV,gBADMyB,EAAAzB,GAAA,GAMN,mBALayB,EAAAzB,IAMb,0BADgByB,EAAAzB,GAAA,GAGhB,YAFuByB,EAAAzB,GAEd,0BAAAyB,EAAApB,OAAA,SAhCHhB,EAASoN,MAAS,WAEfpN,EAAUkgB,cAAe,CAAF9d,EAAAxB,KAAA,eAAAwB,EAAApB,OAAA,SAChBhB,EAAUkgB,iBAAe,cAAA9d,EAAApB,OAAA,uBAMtCyM,EAAO7X,YAAYmE,EAAAA,EAAAA,IAAY0T,EAAO7X,UAAS,CAAAwM,EAAAxB,KAAA,SACpC,OADoCwB,EAAAxB,KAAA,GAC9Bmf,GAAYd,EAAQgB,GAAmB,QAAxDjgB,EAAQoC,EAAArB,KAAA,eAAAqB,EAAApB,OAAA,SAELhB,EAASoN,GAAQK,EAAOhY,QAASgY,EAAO7X,UAAY,WAAS,YAEhE6X,EAAO7X,YAAYmE,EAAAA,EAAAA,IAAY0T,EAAO7X,UAAS,CAAAwM,EAAAxB,KAAA,SACpC,OADoCwB,EAAAxB,KAAA,GAC9Bmf,GAAYd,EAAQgB,GAAmB,QAAxDjgB,EAAQoC,EAAArB,KAAA,eAAAqB,EAAApB,OAAA,SAELhB,EAASmgB,aAAa1S,EAAOhY,QAASgY,EAAOM,SAAUN,EAAO7X,UAAY,WAAS,YAEtF6X,EAAO7X,YAAYmE,EAAAA,EAAAA,IAAY0T,EAAO7X,UAAS,CAAAwM,EAAAxB,KAAA,SACpC,OADoCwB,EAAAxB,KAAA,GAC9Bmf,GAAYd,EAAQgB,GAAmB,QAAxDjgB,EAAQoC,EAAArB,KAAA,eAAAqB,EAAApB,OAAA,SAELhB,EAAUyN,EAAOsC,oBAAsB,2BAA4B,YAAatC,EAAO7X,UAAY6X,EAAOpX,YAAU,YAGvHoX,EAAO7X,YAAYmE,EAAAA,EAAAA,IAAY0T,EAAO7X,UAAS,CAAAwM,EAAAxB,KAAA,SACpC,OADoCwB,EAAAxB,KAAA,GAC9Bmf,GAAYd,EAAQgB,GAAmB,QAAxDjgB,EAAQoC,EAAArB,KAAA,eAAAqB,EAAApB,OAAA,SAELhB,EAASoN,GAAQK,EAAOvX,cAAY,eAAAkM,EAAApB,OAAA,SAGpChB,EAASoN,GAAQK,EAAOjW,kBAAgB,QAErB,MAAtBwB,EAASyU,EAAOzU,QACRC,YAAac,EAAAA,EAAAA,IAAYf,EAAOC,YAAgBD,EAAOG,UAAWY,EAAAA,EAAAA,IAAYf,EAAOG,UAAS,CAAAiJ,EAAAxB,KAAA,SAC3F,OAD2FwB,EAAAxB,KAAA,GACrFmf,GAAYd,EAAQgB,GAAmB,QAAxDjgB,EAAQoC,EAAArB,KAAA,eAAAqB,EAAApB,OAAA,SAELhB,EAAS2I,QAAQ3P,IAAO,eAAAoJ,EAAApB,OAAA,SAIhCpM,GAAO+M,WAAW,uBAAwB9M,EAAAA,GAAOsM,OAAOsF,cAAe,CAC1E2G,OAAQA,EACRK,OAAQA,KACV,yBAAArL,EAAAf,OAAA,GAAAoB,EAAA,I,CAGC,IAAM2d,GAAiB,SAAA7J,IAAArR,EAAAA,EAAAA,GAAAkb,EAAA7J,GAAA,IAAApR,GAAAC,EAAAA,EAAAA,GAAAgb,GAS1B,SAAAA,EAAYC,EAAqDV,GAAe,IAAAnqB,GAAAT,EAAAA,EAAAA,GAAA,KAAAqrB,GAC5ExrB,GAAOI,SAAS,gBAADorB,EAAA,KAAAnrB,iBAAA,EAAamrB,GAEH,IAArBC,EAAUnmB,QACVtF,GAAOoF,mBAAmB,oBAAqB,YAAaqmB,GAGhE,IAAMC,EAAiDD,EAAUzkB,KAAI,SAAC2kB,EAAkBC,GACpF,GAAIlb,EAAAA,GAASmb,WAAWF,GAAmB,CACvC,IAAMG,EAAepkB,EAAoBikB,GAAoB,IAAM,IAEnE,OAAOrjB,OAAOwZ,OAAO,CAAE1W,SAAUugB,EAAkBrB,OAAQ,EAAGwB,aAAAA,EAAcC,SAD3D,G,CAIrB,IAAM1B,GAAiCnmB,EAAAA,EAAAA,IAAYynB,GAE5B,MAAnBtB,EAAO0B,WAAoB1B,EAAO0B,SAAW,GACtB,MAAvB1B,EAAOyB,eACPzB,EAAOyB,aAAepkB,EAAoBikB,GAAoB,IAAM,KAEnD,MAAjBtB,EAAOC,SAAkBD,EAAOC,OAAS,GAE7C,IAAMA,EAASD,EAAOC,OAKtB,OAJIA,EAAS,GAAKA,EAAS,KAAOA,EAAS,IACvCtqB,GAAOoF,mBAAmB,8CAA+C,aAAFuF,OAAgBihB,EAAM,YAAYtB,GAGtGhiB,OAAOwZ,OAAOuI,EACzB,IAEM2B,EAAQN,EAAgBlE,QAAO,SAACC,EAAOmD,GAAC,OAAMnD,EAAQmD,EAAEN,MAAM,GAAG,GAEzD,MAAVS,EACAA,EAASiB,EAAQ,EACVjB,EAASiB,GAChBhsB,GAAOoF,mBAAmB,oDAAqD,SAAU2lB,GAI7F,IAAIlJ,EAA6CyH,GAAcoC,EAAgB1kB,KAAI,SAAC4jB,GAAC,OAAYA,EAAExf,SAAWqF,OAAO,KAiBvF,OAdR,MAAlBoR,IACAA,EAAiB,IAAIzY,SAAQ,SAACC,EAASuM,GACnCtM,YAAW,WACP1I,EAAKoQ,gBAAgBgB,KAAK3I,EAASuM,EACvC,GAAG,EACP,KAGJhV,EAAA2P,EAAAtE,KAAA,KAAM4V,IAGNjY,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,kBAAmB0H,OAAOwZ,OAAO4J,KACtD9hB,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,SAAUmqB,GAE/BnqB,EAAKkqB,qBAAuB,EAAElqB,CAClC,CAuLC,OAvLAH,EAAAA,EAAAA,GAAA+qB,EAAA,EAAA9qB,IAAA,gBAAAC,MAEK,W,sIACe,O,SAAMyI,QAAQ4K,IAAI1T,KAAKorB,gBAAgB1kB,KAAI,SAAC4jB,GAAC,OAAKA,EAAExf,SAASyH,YAAY,KAAE,OAA9E,OAAR0W,EAAQxb,EAAA5B,KAAA4B,EAAA3B,OAAA,SACPkd,GAAcC,IAAS,wBAAAxb,EAAAtB,OAAA,GAAA+C,EAAA,S,GACjC,CAAA9O,IAAA,UAAAC,MAEK,SAAQ6X,EAAgBK,G,kKAEX,oBAAXL,EAA4B,CAAA5G,EAAA5F,KAAA,SACW,OADX4F,EAAA5F,KAAA,EACiB5C,QAAQ4K,IAAI1T,KAAKorB,gBAAgB1kB,KAAI,SAAC4jB,GAC/E,OAAOA,EAAExf,SAAS6gB,gBAAgBpT,EAAOiB,mBAAmB9H,MAAK,SAAC3M,GAC9D,OAAOA,EAAOnE,IAClB,IAAG,SAAC2E,GACA,OAAOA,CACX,GACJ,KAAG,OANGqmB,EAAOta,EAAAzF,KASJ+B,EAAI,EAAC,YAAEA,EAAIge,EAAQ5mB,QAAM,CAAAsM,EAAA5F,KAAA,SACL,GACF,kBADjB3G,EAAS6mB,EAAQhe,IACQ,CAAA0D,EAAA5F,KAAA,eAAA4F,EAAAxF,OAAA,SAAW/G,GAAM,OAFhB6I,IAAG0D,EAAA5F,KAAA,sBAMjCkgB,EAAQ,GAAE,YAKc,IAA9B5rB,KAAKwqB,qBAAyC,mBAAXtS,EAA2B,CAAA5G,EAAA5F,KAAA,SAC9D,OAD8D4F,EAAA5F,KAAA,GACxD1L,KAAK+U,iBAAgB,QAGzB4P,EAAcwF,GAAenqB,KAAMkY,EAAQK,IAI3C8R,EAAgC1B,GAAS3oB,KAAKorB,gBAAgB1kB,IAAI9C,EAAAA,MAChEsE,MAAK,SAAC8Z,EAAGqH,GAAC,OAAMrH,EAAEyJ,SAAWpC,EAAEoC,QAAQ,IAEzCV,EAAqB/qB,KAAKwqB,oBAE5B5c,EAAI,EACJie,GAAQ,EAAIC,GAAA1V,EAAAA,EAAAA,KAAAC,MAAA,SAAAyV,IAAA,IAAArgB,EAAAsgB,EAAAC,EAAAC,EAAAL,EAAAM,EAAAjgB,EAAA,OAAAmK,EAAAA,EAAAA,KAAAI,MAAA,SAAA/G,GAAA,cAAAA,EAAAjE,KAAAiE,EAAA/D,MAAA,OAEND,EAAKqJ,KAGPiX,EAAiB1B,EAAQvmB,QAAO,SAACwmB,GAAC,OAAMA,EAAE/W,QAAY9H,EAAK6e,EAAEJ,MAASI,EAAEkB,YAAa,IAC5DtE,QAAO,SAACC,EAAOmD,GAAC,OAAMnD,EAAQmD,EAAEN,MAAM,GAAG,GAEtEgC,GAAA5V,EAAAA,EAAAA,KAAAC,MAAA,SAAA2V,IAAA,IAAAjC,EAAAjF,EAAA,OAAA1O,EAAAA,EAAAA,KAAAI,MAAA,SAAArH,GAAA,cAAAA,EAAA3D,KAAA2D,EAAAzD,MAAA,OAEUqe,EAASM,EAAQzc,KAEjBkX,EAAM0E,KAEZO,EAAOG,MAAQpV,KACfiV,EAAOoC,QAAUvjB,GAAMmhB,EAAOyB,cAC9BzB,EAAOoC,QAAQ/S,MAAK,WAAQ2Q,EAAOoC,QAAU,IAAM,IAEnDpC,EAAOxW,OAASuX,GAAUf,EAAQgB,EAAoB7S,EAAQK,GAAQ7G,MAAK,SAAC3M,GACxEglB,EAAOvU,MAAO,EACduU,EAAOhlB,OAASA,EAEZwB,EAAK+c,cAAc,UACnB/c,EAAKyK,KAAK,QAAS,CACfoR,OAAQ,UACR0C,IAAKA,EACLsH,QAAStC,GAAkBC,EAAQjV,MACnCmN,QAAS,CAAE/J,OAAQA,EAAQK,QAAQ8J,EAAAA,EAAAA,IAAS9J,IAC5CzN,SAAUvE,GAItB,IAAG,SAAChB,GACAwkB,EAAOvU,MAAO,EACduU,EAAOxkB,MAAQA,EAEXgB,EAAK+c,cAAc,UACnB/c,EAAKyK,KAAK,QAAS,CACfoR,OAAQ,UACR0C,IAAKA,EACLsH,QAAStC,GAAkBC,EAAQjV,MACnCmN,QAAS,CAAE/J,OAAQA,EAAQK,QAAQ8J,EAAAA,EAAAA,IAAS9J,IAC5CzN,SAAUvE,GAGtB,IAEIA,EAAK+c,cAAc,UACnB/c,EAAKyK,KAAK,QAAS,CACfoR,OAAQ,UACR0C,IAAKA,EACLsH,QAAStC,GAAkBC,EAAQ,MACnC9H,QAAS,CAAE/J,OAAQA,EAAQK,QAAQ8J,EAAAA,EAAAA,IAAS9J,IAC5CzN,SAAUvE,IAIlBwlB,GAAkBhC,EAAOC,OAAO,wBAAA7a,EAAAhD,OAAA,GAAA6f,EAAA,gBAhD7BD,EAAiBxlB,EAAKkkB,QAAU7c,EAAIyc,EAAQrlB,QAAM,CAAAyK,EAAA/D,KAAA,eAAA+D,EAAA4c,cAAAL,IAAA,eAAAvc,EAAA/D,KAAA,eAyDtD,GALGugB,EAA+B,GACrC5B,EAAQpjB,SAAQ,SAACqjB,IACTA,EAAE9U,MAAS8U,EAAE/W,SACjB0Y,EAAQ/kB,KAAKojB,EAAE/W,QACX+W,EAAE6B,SAAWF,EAAQ/kB,KAAKojB,EAAE6B,QAAQxC,cAC5C,KAEIsC,EAAQjnB,OAAQ,CAAFyK,EAAA/D,KAAA,SAAI,OAAJ+D,EAAA/D,KAAA,GAAU5C,QAAQwjB,KAAKL,GAAQ,QAIiB,MAA5DL,EAAUvB,EAAQvmB,QAAO,SAACwmB,GAAC,OAAMA,EAAE9U,MAAmB,MAAX8U,EAAE/kB,KAAa,KACpDP,QAAUuB,EAAKkkB,QAAM,CAAAhb,EAAA/D,KAAA,SACM,QACpB1H,KADTe,EAAS4f,EAAYiH,IACH,CAAAnc,EAAA/D,KAAA,SAKjB,OAHH2e,EAAQpjB,SAAQ,SAAAqjB,GACRA,EAAE6B,SAAW7B,EAAE6B,QAAQ1C,SAC3Ba,EAAEhT,WAAY,CAClB,IAAG7H,EAAA3D,OAAA,UAAA7J,EACI8C,IAAM,WAEZ8mB,EAAO,CAAFpc,EAAA/D,KAAA,SAAI,OAAJ+D,EAAA/D,KAAA,GAAU9C,GAAM,KAAK+gB,aAAY,QAC3CkC,GAAQ,EAAM,QAqClB,GAjCM5f,EAASoe,EAAQnD,QAAO,SAACC,EAAOmD,GAClC,IAAKA,EAAE9U,MAAmB,MAAX8U,EAAE/kB,MAAiB,OAAO4hB,EAEzC,IAAMnb,EAAcse,EAAE/kB,MAAQyG,KAM9B,OALI4d,GAActhB,QAAQ0D,IAAS,IAC1Bmb,EAAMnb,KAASmb,EAAMnb,GAAQ,CAAEzG,MAAO+kB,EAAE/kB,MAAOykB,OAAQ,IAC5D7C,EAAMnb,GAAMge,QAAUM,EAAEN,QAGrB7C,CACX,GAA4D,CAAC,GAE7Dnf,OAAOC,KAAKgE,GAAQhF,SAAQ,SAACslB,GACzB,IAAM7B,EAAQze,EAAOsgB,GACrB,KAAI7B,EAAMV,OAASzjB,EAAKkkB,QAAxB,CAGAJ,EAAQpjB,SAAQ,SAAAqjB,GACRA,EAAE6B,SAAW7B,EAAE6B,QAAQ1C,SAC3Ba,EAAEhT,WAAY,CAClB,IAEA,IAAMsG,EAAU8M,EAAMnlB,MAEhBinB,EAAmC,CAAC,EAC1C3C,GAAkB5iB,SAAQ,SAAC8D,GACR,MAAX6S,EAAE7S,KACNyhB,EAAMzhB,GAAQ6S,EAAE7S,GACpB,IAEArL,GAAO+M,WAAWmR,EAAE7G,QAAU6G,EAAEmB,QAAcwN,EAAWC,E,CAC7D,IAG8C,IAA1CnC,EAAQvmB,QAAO,SAACwmB,GAAC,OAAMA,EAAE9U,IAAI,IAAExQ,OAAY,CAAAyK,EAAA/D,KAAA,gBAAA+D,EAAA3D,OAAA,2CAAA2D,EAAAtD,OAAA,GAAA2f,EAAA,YAzHxC,OAAAxa,EAAA+a,cAAAP,IAAA,+BAAAW,EAAAnb,EAAA7F,IAAA,CAAA6F,EAAA5F,KAAA,gBAAA4F,EAAAxF,OAAA,yCAAA2gB,EAAA,CAAAnb,EAAA5F,KAAA,gBAAA4F,EAAAxF,OAAA,SAAA2gB,EAAAxqB,GAAA,QAAAqP,EAAA5F,KAAA,iBAgIR,OAHH2e,EAAQpjB,SAAQ,SAAAqjB,GACRA,EAAE6B,SAAW7B,EAAE6B,QAAQ1C,SAC3Ba,EAAEhT,WAAY,CAClB,IAAGhG,EAAAxF,OAAA,SAEIpM,GAAO+M,WAAW,wBAAyB9M,EAAAA,GAAOsM,OAAOgM,aAAc,CAC1EC,OAAQA,EACRK,OAAQA,EAGRqT,QAASvB,EAAQ3jB,KAAI,SAAC4jB,GAAC,OAAKR,GAAkBQ,EAAE,IAChDxf,SAAU9K,QACZ,yBAAAsR,EAAAnF,OAAA,GAAAmD,EAAA,S,KACL4b,CAAA,CAzPyB,CAAQpb,GChZhC4c,GAAmB,KCSnBhtB,GAAS,IAAIC,EAAAA,GAAOF,GAKpBktB,GAAmB,mCAEZC,GAAwB,SAAA5G,IAAAhW,EAAAA,EAAAA,GAAA4c,EAAA5G,GAAA,IAAA/V,GAAAC,EAAAA,EAAAA,GAAA0c,GAKjC,SAAAA,EAAYzc,EAAsByV,GAAY,IAAAtlB,GAAAT,EAAAA,EAAAA,GAAA,KAAA+sB,GAC1C,IAAM9hB,EAAW,IAAI+hB,GAAe1c,EAASyV,GACvCrD,EAAazX,EAASyX,WACxBA,EAAWxB,UACXrhB,GAAO+M,WAAW,+CAAgD9M,EAAAA,GAAOsM,OAAOS,sBAAuB,CACnGC,UAAW,0CAInB,IAAMmB,EAAMyU,EAAWzU,IAAI1H,QAAQ,SAAU,MAAMA,QAAQ,OAAQ,WAKL,OAJ9D9F,EAAA2P,EAAAtE,KAAA,KAAMmC,EAAKqC,IAEX7G,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,SAAUwK,EAASgiB,YACxCxjB,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,YAAawK,EAASgiB,YAC3CxjB,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAlQ,GAAO,gBAAiBwK,EAASiiB,eAAezsB,CAClE,CAIC,OAJAH,EAAAA,EAAAA,GAAAysB,EAAA,EAAAxsB,IAAA,sBAAAC,MAED,WACI,OAAQL,KAAK8sB,YAAcH,EAC/B,KAACC,CAAA,CAxBgC,CAAQ/I,IA2BhCgJ,GAAe,SAAA3G,IAAAlW,EAAAA,EAAAA,GAAA6c,EAAA3G,GAAA,IAAAhF,GAAAhR,EAAAA,EAAAA,GAAA2c,GAAA,SAAAA,IAAA,OAAAhtB,EAAAA,EAAAA,GAAA,KAAAgtB,GAAA3L,EAAA3C,MAAA,KAAAL,UAAA,CAsFvB,OAtFuB/d,EAAAA,EAAAA,GAAA0sB,EAAA,EAAAzsB,IAAA,sBAAAC,MAwFxB,WACI,OAAQL,KAAK8sB,YAAcH,EAC/B,IAAC,EAAAvsB,IAAA,uBAAAC,MAtFD,SAA4B8P,EAAsByV,GAC9C,OAAO,IAAIgH,GAAwBzc,EAASyV,EAChD,GAAC,CAAAxlB,IAAA,YAAAC,MAED,SAAiBulB,GACb,IAAMoH,EAA0E,CAC5EpH,OAAQ+G,GACRG,UAAWH,GACXI,cAAe,MAGnB,OAAc,MAAVnH,IAEmB,kBAAZA,EACPoH,EAAUF,UAAYlH,EAES,MAAxBA,EAAOmH,eACdrtB,GAAOutB,eAA6C,kBAAtBrH,EAAOkH,UACjC,qCAAsC,YAAalH,EAAOkH,WAC9DptB,GAAOutB,eAAiD,kBAA1BrH,EAAOmH,cACjC,wBAAyB,gBAAiB,cAE9CC,EAAUF,UAAYlH,EAAOkH,UAC7BE,EAAUD,cAAgBnH,EAAOmH,eAE1BnH,EAAOkH,YACdE,EAAUF,UAAYlH,EAAOkH,WAGjCE,EAAUpH,OAASoH,EAAUF,WAlBAE,CAqBjC,GAAC,CAAA5sB,IAAA,SAAAC,MAED,SAAc8P,EAAkByV,GAC5B,IAAIO,EAAe,KACnB,OAAOhW,EAAUA,EAAQpF,KAAM,WAC3B,IAAK,YACDob,EAAO,oBACP,MACJ,IAAK,UACDA,EAAO,oBACP,MACJ,IAAK,UACDA,EAAO,oBACP,MACJ,IAAK,QACDA,EAAO,kBACP,MACJ,IAAK,SACDA,EAAO,mBACP,MACJ,IAAK,QACDA,EAAO,4BACP,MACJ,IAAK,WACDA,EAAO,2BACP,MACJ,QACIzmB,GAAO+M,WAAW,sBAAuB9M,EAAAA,GAAOsM,OAAOihB,iBAAkB,CACrEC,SAAU,UACV9sB,MAAO8P,IAInB,IAAMoS,EAA6B,CAC/B6D,WAAW,EACXtY,IAAM,WAAkBqY,EAAO,OAASP,EAAOkH,UAC/CzG,iBAAkB,SAACC,EAAiBxY,GAIhC,OAHI8X,EAAOkH,YAAcH,IACrBrlB,IAEGwB,QAAQC,SAAQ,EAC3B,GAQJ,OAL4B,MAAxB6c,EAAOmH,gBACPxK,EAAW6K,KAAO,GAClB7K,EAAWxB,SAAW6E,EAAOmH,eAG1BxK,CACX,KAACsK,CAAA,CAtFuB,CAAQnH,ICrCvB2H,GAAqB,SAAAvJ,IAAA9T,EAAAA,EAAAA,GAAAqd,EAAAvJ,GAAA,IAAA7T,GAAAC,EAAAA,EAAAA,GAAAmd,GAAA,SAAAA,IAAA,OAAAxtB,EAAAA,EAAAA,GAAA,KAAAwtB,GAAApd,EAAAsO,MAAA,KAAAL,UAAA,CAuF7B,OAvF6B/d,EAAAA,EAAAA,GAAAktB,EAAA,EAAAjtB,IAAA,OAAAC,MAQ9B,SAAK6X,EAAgBK,GAAkB,IAAAjY,EAAA,KAC7B2hB,EAAU,CACZ/J,OAAQA,EACRK,OAAQA,EACR2J,GAAKliB,KAAKyhB,UACVU,QAAS,OAGa,MAAtBniB,KAAKstB,gBACLttB,KAAKstB,cAAgB,IAGzB,IAAMC,EAAuB,CAAEtL,QAAAA,EAASlZ,QAAS,KAAMuM,OAAQ,MAEzDoU,EAAU,IAAI5gB,SAAQ,SAACC,EAASuM,GAClCiY,EAAgBxkB,QAAUA,EAC1BwkB,EAAgBjY,OAASA,CAC7B,IA6DA,OA3DAtV,KAAKstB,cAAcpmB,KAAKqmB,GAEnBvtB,KAAKwtB,0BAENxtB,KAAKwtB,wBAA0BxkB,YAAW,WAItC,IAAMykB,EAAQntB,EAAKgtB,cACnBhtB,EAAKgtB,cAAgB,KACrBhtB,EAAKktB,wBAA0B,KAG/B,IAAMvL,EAAUwL,EAAM/mB,KAAI,SAACgnB,GAAQ,OAAKA,EAASzL,OAAO,IAQxD,OANA3hB,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,eACRH,SAASI,EAAAA,EAAAA,IAASJ,GAClBnX,SAAUxK,KAGPsO,EAAAA,EAAAA,IAAUtO,EAAKiiB,WAAYxT,KAAKC,UAAUiT,IAAUvQ,MAAK,SAAC3M,GAC7DzE,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,WACRH,QAASA,EACTO,SAAUzd,EACV+F,SAAUxK,IAKdmtB,EAAMxmB,SAAQ,SAACsmB,EAAiBjC,GAC5B,IAAM/L,EAAUxa,EAAOumB,GACvB,GAAI/L,EAAQha,MAAO,CACf,IAAMA,EAAQ,IAAIb,MAAM6a,EAAQha,MAAMwZ,SAChCxZ,EAAOyG,KAAOuT,EAAQha,MAAMyG,KAC5BzG,EAAO5E,KAAO4e,EAAQha,MAAM5E,KAClC4sB,EAAgBjY,OAAO/P,E,MAEvBgoB,EAAgBxkB,QAAQwW,EAAQxa,OAExC,GAEJ,IAAG,SAACQ,GACAjF,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,WACR7c,MAAOA,EACP0c,QAASA,EACTnX,SAAUxK,IAGdmtB,EAAMxmB,SAAQ,SAACsmB,GACXA,EAAgBjY,OAAO/P,EAC3B,GACJ,GAEJ,GAAG,KAGAmkB,CACX,KAAC2D,CAAA,CAvF6B,CAAQjM,ICCpC1hB,GAAS,IAAIC,EAAAA,GAAOF,GAKbkuB,GAAkB,SAAAzH,IAAAlW,EAAAA,EAAAA,GAAA2d,EAAAzH,GAAA,IAAAjW,GAAAC,EAAAA,EAAAA,GAAAyd,GAAA,SAAAA,IAAA,OAAA9tB,EAAAA,EAAAA,GAAA,KAAA8tB,GAAA1d,EAAAsO,MAAA,KAAAL,UAAA,CAkC1B,OAlC0B/d,EAAAA,EAAAA,GAAAwtB,EAAA,OAAAvtB,IAAA,YAAAC,MAE3B,SAAiBulB,GAIb,OAHIA,GAA6B,kBAAZA,GACjBlmB,GAAOoF,mBAAmB,iBAAkB,SAAU8gB,GAEnDA,GARO,kBASlB,GAAC,CAAAxlB,IAAA,SAAAC,MAED,SAAc8P,EAAkByV,GAC5BlmB,GAAO+I,KAAK,qFAEZ,IAAI0d,EAAO,KACX,OAAQhW,EAAQpF,MACZ,IAAK,YACDob,EAAO,uDACP,MACJ,IAAK,UACDA,EAAO,uDACP,MACJ,IAAK,UACDA,EAAO,uDACP,MACJ,IAAK,SACDA,EAAO,sDACP,MACJ,IAAK,QACDA,EAAO,qDACP,MACJ,QACGzmB,GAAOoF,mBAAmB,sBAAuB,UAAWoZ,UAAU,IAG7E,OAAQiI,EAAO,WAAaP,CAChC,KAAC+H,CAAA,CAlC0B,CAAQjI,ICNjChmB,GAAS,IAAIC,EAAAA,GAAOF,GAKpBmuB,GAAgD,CAClDC,UAAW,2BACXC,QAAS,2BACTC,QAAS,2BACTC,OAAQ,4BAGCC,GAAe,SAAA/H,IAAAlW,EAAAA,EAAAA,GAAAie,EAAA/H,GAAA,IAAAjW,GAAAC,EAAAA,EAAAA,GAAA+d,GAKxB,SAAAA,EAAY9d,EAAsByV,GAI9B,IAJ0C/lB,EAAAA,EAAAA,GAAA,KAAAouB,GAI5B,MAAVrI,EAAgB,CAChB,IAAMsI,GAAInd,EAAAA,EAAAA,IAAS,gBAAAkd,EAAA,KAAAluB,iBAAA,EAA+C,aAAxDgR,CAAsEZ,GAChF,GAAI+d,EAAG,CACH,IAAMC,EAAgBP,GAAsBM,EAAEnjB,MAC1CojB,IACAvI,EAAS,CACLuI,cAAeA,EACfC,cAAc,G,CAMZ,MAAVxI,GACAlmB,GAAO+M,WAAW,sBAAuB9M,EAAAA,GAAOsM,OAAOihB,iBAAkB,CACrEC,SAAU,UACV9sB,MAAO8P,G,CAIlB,OAAAF,EAAAtE,KAAA,KAEKwE,EAASyV,EACnB,CAsFC,OAtFAzlB,EAAAA,EAAAA,GAAA8tB,EAAA,EAAA7tB,IAAA,sBAAAC,MAwFD,WACI,OAAQL,KAAKmuB,gBAAkBP,GAAsB5tB,KAAKmQ,QAAQpF,KACtE,IAAC,EAAA3K,IAAA,YAAAC,MAxFD,SAAiBulB,GAKC,MAAVA,GACAlmB,GAAOoF,mBAAmB,wDAAyD,SAAU8gB,GAGjG,IAAMoH,EAA4F,CAC9FmB,cAAe,KACfC,cAAc,EACdC,qBAAsB,MA4B1B,MAxBwB,kBAAZzI,EACRoH,EAAUmB,cAAgBvI,EAEY,MAA/BA,EAAOyI,sBACd3uB,GAAOutB,eAAkD,kBAA1BrH,EAAOuI,cAClC,iDAAkD,gBAAiBvI,EAAOuI,eAC9EzuB,GAAOutB,eAAyD,kBAAjCrH,EAAOyI,qBAClC,+BAAgC,uBAAwB,cAE5DrB,EAAUmB,cAAgBvI,EAAOuI,cACjCnB,EAAUqB,qBAAuBzI,EAAOyI,qBACxCrB,EAAUoB,eAAiBxI,EAAOwI,cAE3BxI,EAAOuI,eACdzuB,GAAOutB,eAAkD,kBAA1BrH,EAAOuI,cAClC,wCAAyC,uBAAwBvI,EAAOuI,eAE5EnB,EAAUmB,cAAgBvI,EAAOuI,cACjCnB,EAAUoB,eAAiBxI,EAAOwI,cAGlC1uB,GAAOoF,mBAAmB,oCAAqC,SAAU8gB,GAGtEoH,CACX,GAAC,CAAA5sB,IAAA,SAAAC,MAED,SAAc8P,EAAkByV,GAC5B,IAAIO,EAAe,KACnB,OAAQhW,EAAUA,EAAQpF,KAAO,WAC7B,IAAK,YACDob,EAAO,mCACP,MACJ,IAAK,UACDA,EAAO,mCACP,MACJ,IAAK,UACDA,EAAO,mCACP,MACJ,IAAK,SACDA,EAAO,kCACP,MACJ,QACIzmB,GAAO+M,WAAW,sBAAuB9M,EAAAA,GAAOsM,OAAOihB,iBAAkB,CACrEC,SAAU,UACV9sB,MAAO8P,IAInB,IAOMoS,EAA6B,CAAEzU,IANjC8X,EAAOwI,aACD,WAAH/jB,OAAgB8b,EAAK,WAAA9b,OAAWub,EAAOuI,eAEpC,WAAH9jB,OAAgB8b,EAAK,QAAA9b,OAAQub,EAAOuI,eAM3C5L,QAAqB,CAAC,GAQtB,OALmC,MAA/BqD,EAAOyI,uBACP9L,EAAW6K,KAAO,GAClB7K,EAAWxB,SAAW6E,EAAOyI,sBAG1B9L,CACX,KAAC0L,CAAA,CAtHuB,CAAQvI,ICb9BhmB,GAAS,IAAIC,EAAAA,GAAOF,GAetBgiB,GAAU,EAMd,SAAS6M,GAAuBxjB,EAA4ByjB,GACxD,IAAMC,EAAU,oBAEhB,OAAO,SAAStW,EAAgBK,GAAkB,IAAAjY,EAAA,KACxC2hB,EAAU,CACZ/J,OAAQA,EACRK,OAAQA,EACR2J,GAAKT,KACLU,QAAS,OAGb,OAAO,IAAIrZ,SAAQ,SAACC,EAASuM,GACzBhV,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,UACRoM,QAAAA,EACAvM,SAASI,EAAAA,EAAAA,IAASJ,GAClBnX,SAAUxK,IAGdiuB,EAAStM,GAAS,SAAC1c,EAAOid,GAEtB,GAAIjd,EASA,OARAjF,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,WACRoM,QAAAA,EACAjpB,MAAAA,EACA0c,QAAAA,EACAnX,SAAUxK,IAGPgV,EAAO/P,GAWlB,GARAjF,EAAK0Q,KAAK,QAAS,CACfoR,OAAQ,WACRoM,QAAAA,EACAvM,QAAAA,EACAO,SAAAA,EACA1X,SAAUxK,IAGVkiB,EAASjd,MAAO,CAChB,IAAMA,EAAQ,IAAIb,MAAM8d,EAASjd,MAAMwZ,SAGvC,OAFMxZ,EAAOyG,KAAOwW,EAASjd,MAAMyG,KAC7BzG,EAAO5E,KAAO6hB,EAASjd,MAAM5E,KAC5B2U,EAAO/P,E,CAGlBwD,EAAQyZ,EAASzd,OACrB,GACJ,GACJ,CACJ,CAwCO,IAAM0pB,GAAa,SAAA3K,IAAA9T,EAAAA,EAAAA,GAAAye,EAAA3K,GAAA,IAAA7T,GAAAC,EAAAA,EAAAA,GAAAue,GAItB,SAAAA,EAAY3jB,EAA+CqF,GAAoB,IAAAsC,GAAA5S,EAAAA,EAAAA,GAAA,KAAA4uB,GAC3E/uB,GAAOI,SAAS,gBAAD2uB,EAAA,KAAA1uB,iBAAA,EAAa0uB,GAEZ,MAAZ3jB,GACApL,GAAOoF,mBAAmB,mBAAoB,WAAYgG,GAG9D,IAAI4jB,EAAe,KACfC,EAAqC,KACrCC,EAAgC,KA+BU,MA7BrB,oBAAd9jB,GACP4jB,EAAO,WACPC,EAAmB7jB,MAGnB4jB,EAAO5jB,EAASqb,MAAQrb,EAAS4jB,MAAQ,KAC5B5jB,EAAS+jB,aAClBH,EAAO,YAGXE,EAAc9jB,EAEVA,EAASmX,SACI,KAATyM,IAAeA,EAAO,aAC1BC,EAnEhB,SAA6B7jB,GACzB,OAAO,SAASoN,EAAgBK,GAAkB,IAAAhS,EAAA,KAChC,MAAVgS,IAAkBA,EAAS,IAE/B,IAAM0J,EAAU,CAAE/J,OAAAA,EAAQK,OAAAA,GAS1B,OAPAvY,KAAKgR,KAAK,QAAS,CACfoR,OAAQ,UACRoM,QAAS,iBACTvM,SAASI,EAAAA,EAAAA,IAASJ,GAClBnX,SAAU9K,OAGP8K,EAASmX,QAAQA,GAASvQ,MAAK,SAAC8Q,GASnC,OARAjc,EAAKyK,KAAK,QAAS,CACfoR,OAAQ,WACRoM,QAAS,iBACTvM,QAAAA,EACAO,SAAAA,EACA1X,SAAUvE,IAGPic,CAEX,IAAG,SAACjd,GASA,MARAgB,EAAKyK,KAAK,QAAS,CACfoR,OAAQ,WACRoM,QAAS,iBACTvM,QAAAA,EACA1c,MAAAA,EACAuF,SAAUvE,IAGRhB,CACV,GACJ,CACJ,CA+BmCupB,CAAoBhkB,IAChCA,EAASikB,UAChBJ,EAAmBL,GAAuBxjB,EAAUA,EAASikB,UAAUvuB,KAAKsK,IACrEA,EAASmV,KAChB0O,EAAmBL,GAAuBxjB,EAAUA,EAASmV,KAAKzf,KAAKsK,IAEvEpL,GAAOoF,mBAAmB,uBAAwB,WAAYgG,GAG7D4jB,IAAQA,EAAO,aAGxBjc,EAAAxC,EAAAtE,KAAA,KAAM+iB,EAAMve,IAEZ7G,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAiC,GAAO,mBAAoBkc,IACzCrlB,EAAAA,EAAAA,KAAckH,EAAAA,EAAAA,GAAAiC,GAAO,WAAYmc,GAAanc,CAClD,CAIC,OAJAtS,EAAAA,EAAAA,GAAAsuB,EAAA,EAAAruB,IAAA,OAAAC,MAED,SAAK6X,EAAgBK,GACjB,OAAOvY,KAAK2uB,iBAAiBzW,EAAQK,EACzC,KAACkW,CAAA,CAjDqB,CAAQrN,IChF5B1hB,GAAS,IAAIC,EAAAA,GAAOF,GAK1B,SAASuvB,GAAmB7e,EAAsB8e,GAI9C,GAHe,MAAX9e,IAAmBA,EAAU,aAGT,kBAAbA,EAAuB,CAI9B,IAAMrD,EAAQqD,EAAQrD,MAAM,kBAC5B,GAAIA,EACA,OAAQA,EAAM,IACV,IAAK,OACD,OAAO,IAAIsU,GAAgBjR,GAC/B,IAAK,KACD,OAAO,IAAI0T,GAAkB1T,GACjC,QACIzQ,GAAOoF,mBAAmB,yBAA0B,UAAWqL,G,CAK/E,IAAM+d,GAAI3b,EAAAA,EAAAA,GAAWpC,GAQrB,OAPK+d,GAAMA,EAAEgB,kBACTxvB,GAAO+M,WAAW,yCAA0C9M,EAAAA,GAAOsM,OAAO0F,cAAe,CACrFhF,UAAW,qBACXwD,QAASA,IAIV+d,EAAEgB,iBAAiB,CACtBhE,iBAAAA,GAEAjF,gBAAAA,GACAM,mBAAAA,GACAO,kBAAAA,GACA+F,eAAAA,GACAzL,gBAAAA,GACAuM,kBAAAA,GACAM,eAAAA,GACAQ,aAAAA,GAEA/B,YAAAA,IACDuC,EACP,C","sources":["../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/src.ts/index.ts"],"sourcesContent":["export const version = \"providers/5.5.0\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: address,\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string): null | string {\n    try {\n        return toUtf8String(_parseBytes(result));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        try {\n            return _parseBytes(await this.provider.call(tx));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const transaction = {\n                    to: this.address,\n                    data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                };\n                const hexBytes = await this.provider.call(transaction);\n\n                // No address\n                if (hexBytes === \"0x\" || hexBytes === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(hexBytes);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ ];\n        try {\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n\n                if (match == null) { continue; }\n                switch (match[1]) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: `https:/\\/gateway.ipfs.io/ipfs/${ avatar.substring(7) }` }\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (match[1] === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: match[1], content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (match[1] === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (match[1] === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n                        let metadataUrl = _parseString(await this.provider.call(tx))\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (match[1] === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                        }\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n\n                        // Pull the image URL out\n                        if (!metadata || typeof(metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n                            return null;\n                        }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                        linkage.push({ type: \"url\", content: metadata.image });\n\n                        return { linkage, url: metadata.image };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        logger.checkNew(new.target, Provider);\n\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    const filter = event.filter;\n                    filter.fromBlock = this._lastBlockNumber + 1;\n                    filter.toBlock = blockNumber;\n\n                    const runner = this.getLogs(filter).then((logs) => {\n                        if (logs.length === 0) { return; }\n                        logs.forEach((log: Log) => {\n                            this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                            this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                            this.emit(filter, log);\n                        });\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n                    runners.push(runner);\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"call\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params, result, error\n            });\n        }\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        try {\n            const address = await this._getResolver(name);\n            if (address == null) { return null; }\n            return new Resolver(this, address, name);\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    async _getResolver(name: string): Promise<string> {\n        // Get the resolver from the blockchain\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        const transaction = {\n            to: network.ensAddress,\n            data: (\"0x0178b8bf\" + namehash(name).substring(2))\n        };\n\n        try {\n            return this.formatter.callAddress(await this.call(transaction));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resovler\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddress = await this._getResolver(reverseName);\n        if (!resolverAddress) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        let bytes = arrayify(await this.call({\n            to: resolverAddress,\n            data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n        }));\n\n        // Strip off the dynamic string pointer (0x20)\n        if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) { return null; }\n        bytes = bytes.slice(32);\n\n        // Not a length-prefixed string\n        if (bytes.length < 32) { return null; }\n\n        // Get the length of the string (from the length-prefix)\n        const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n        bytes = bytes.slice(32);\n\n        // Length longer than available data\n        if (length > bytes.length) { return null; }\n\n        const name = toUtf8String(bytes.slice(0, length));\n\n        // Make sure the reverse record matches the foward record\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(reverseName);\n            if (!resolverAddress) { return null; }\n\n            resolver = new Resolver(this, resolverAddress, \"_\", address);\n\n        } else {\n            // ENS name; forward lookup\n            resolver = await this.getResolver(nameOrAddress);\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction checkError(method: string, error: any, params: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        logger.checkNew(new.target, JsonRpcSigner);\n\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n        return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            address.toLowerCase(),\n            JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        logger.checkNew(new.target, JsonRpcProvider);\n\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), params.position, params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue((<any>transaction)[key]);\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string, network?: Networkish) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        super(url, network);\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this._websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this._websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this._websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this._websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this._websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this._websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        logger.checkNew(new.target, EtherscanProvider);\n\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        logger.checkNew(new.target, FallbackProvider);\n\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        logger.checkNew(new.target, Web3Provider);\n\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n"],"names":["version","logger","Logger","Formatter","_classCallCheck","checkNew","constructor","this","formats","getDefaultFormats","_createClass","key","value","_this","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","shallowCopy","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","BigNumber","toNumber","toLowerCase","Error","strict","substring","isHexString","throwArgumentError","result","length","getAddress","hexDataSlice","AddressZero","getContractAddress","hexValue","hexDataLength","error","hexZeroPad","format","author","_difficulty","check","_block","gas","isZero","input","chainId","networkId","parseInt","replace","parseTransaction","byzantium","_this2","Array","isArray","map","object","checkKey","checkValue","nullValue","replaceValue","array","forEach","push","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","indexOf","ForkEvent","isForkEvent","warn","getTime","Date","stall","duration","Promise","resolve","setTimeout","PollableEvents","Event","tag","listener","once","defineReadOnly","get","split","comps","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","Base58","encode","concat","sha256","matchers","RegExp","_parseString","toUtf8String","_parseBytes","offset","Resolver","provider","name","resolvedAddress","formatter","selector","parameters","tx","hexConcat","namehash","_context","prev","t0","next","call","t1","sent","abrupt","t2","code","errors","CALL_EXCEPTION","stop","_callee","coinType","hexBytes","coinInfo","String","throwError","UNSUPPORTED_OPERATION","operation","bytes","arrayify","match","words","bech32","unshift","_context2","HashZero","callAddress","_fetchBytes","_getAddress","_callee2","linkage","_context3","getText","avatar","i","content","url","_resolvedAddress","owner","addr","tokenId","t3","tokenOwner","t4","t5","balance","toString","t6","t7","metadataUrl","fetchJson","metadata","image","JSON","stringify","t8","_callee3","_context4","ipfs","swarm","_callee4","keyBytes","toUtf8Bytes","_context5","hexlify","_callee5","defaultFormatter","nextPollId","BaseProvider","_Provider","_inherits","_super","_createSuper","network","Provider","_events","_emitted","getFormatter","_assertThisInitialized","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","_context6","UNKNOWN_ERROR","_callee6","poll","then","NETWORK_ERROR","event","maxAge","_context7","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","getNetwork","_ref","_this3","_setFastBlockNumber","_callee7","pollId","runners","_context8","_getInternalBlockNumber","pollingInterval","Math","abs","makeError","previousBlockNumber","eventBlockNumber","_this4","runner","getTransactionReceipt","getLogs","all","_callee8","polling","_context9","_callee9","_context10","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_callee10","_this5","_poller","set","_this6","setInterval","_bootstrapPoll","clearInterval","_this7","_this8","now","getBlockNumber","timeout","_waitForTransaction","_context11","_callee11","replaceable","_context14","reject","cancelFuncs","done","alreadyDone","func","minedHandler","_this9","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","_regeneratorRuntime","mark","_callee13","_this10","wrap","_context13","getTransactionCount","_callee12","mined","ti","_receipt","reason","_context12","getTransaction","getBlockWithTransactions","waitForTransaction","eq","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","_callee14","_context15","_callee15","_context16","SERVER_ERROR","method","_callee16","addressOrName","_context17","_getBlockTag","params","_callee17","_context18","_callee18","_context19","_callee19","position","_context20","p","_callee20","_this11","expectedHash","returnedHash","wait","confirms","_callee21","_context21","signedTransaction","_context22","t","hexTx","_callee22","values","_context23","_this12","_callee23","_context24","_this13","_callee24","_context25","_getTransactionRequest","_callee25","_context26","_callee26","_context27","resolveName","_callee27","blockHashOrBlockTag","includeTransactions","_context29","_this14","_callee28","_blockNumber","blockWithTxs","_this15","_context28","oncePoll","_callee29","_getBlock","_context31","_this16","_callee30","_context30","_callee31","_context33","_this17","_callee32","_context32","_callee33","_context34","_getFilter","_callee34","_context35","_callee35","_context36","_callee36","_getResolver","_context37","_callee37","_context38","ensAddress","_callee38","_context39","getResolver","resolver","_callee39","_context40","reverseName","resolverAddress","_callee40","nameOrAddress","_context41","getAvatar","_callee41","NOT_IMPLEMENTED","e","pollable","_startEvent","_addEventListener","_this18","_len","arguments","args","_key","stopped","eventTag","apply","_stopEvent","_this19","removeAllListeners","found","_this20","errorGas","checkError","message","body","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","_Signer","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","estimateGas","sender","hexlifyTransaction","sendUncheckedTransaction","domain","types","_TypedDataEncoder","resolveNames","populated","getPayload","password","Signer","_JsonRpcSigner","_super2","allowedTransactionKeys","JsonRpcProvider","_BaseProvider","_super3","networkOrReady","freeze","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","serverError","getSigner","connectUnchecked","a","request","id","jsonrpc","action","deepCopy","cache","connection","response","getFeeData","feeData","prepareRequest","_startPending","_get","_getPrototypeOf","prototype","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","checkProperties","WS","WebSocket","NextId","WebSocketProvider","_JsonRpcProvider","_thisSuper","_wsReady","_websocket","onopen","_requests","onmessage","messageEvent","parse","callback","sub","_subs","subscription","processFunc","fauxPoll","_detectNetwork","rid","param","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","CONNECTING","onerror","close","StaticJsonRpcProvider","UrlJsonRpcProvider","_StaticJsonRpcProvide","apiKey","checkAbstract","defaultApiKey","AlchemyWebSocketProvider","_WebSocketProvider","AlchemyProvider","_UrlJsonRpcProvider","host","allowGzip","throttleCallback","attempt","CloudflareProvider","getTransactionPostData","maxFeePerGs","storageKeys","throttleRetry","getJsonResult","checkLogTag","EtherscanProvider","getBaseUrl","module","query","reduce","accum","baseUrl","apikey","post","getPostUrl","getUrl","getPostData","procFunc","throttleSlotInterval","payloadStr","headers","fetch","txhash","postData","topic0","blocks","getBlock","parseFloat","ethusd","endBlock","startblock","endblock","item","timeStamp","shuffled","j","floor","random","tmp","checkNetworks","networks","median","maxDelta","middle","b","serialize","isBigNumber","nextRid","cancel","promise","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","start","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","quorum","tally","count","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","FallbackProvider","providers","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","total","sendTransaction","results","first","_loop","inflightWeight","_loop2","waiting","_result","staller","backend","delegateYield","race","errorCode","props","_ret","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","projectId","projectSecret","apiKeyObj","assertArgument","INVALID_ARGUMENT","argument","user","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","options","_defaultProvider"],"sourceRoot":""}